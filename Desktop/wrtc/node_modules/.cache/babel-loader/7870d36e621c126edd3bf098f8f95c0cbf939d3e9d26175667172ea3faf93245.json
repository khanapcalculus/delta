{"ast":null,"code":"class WebRTCManager {\n  constructor() {\n    this.localConnection = null;\n    this.dataChannel = null;\n    this.isHost = false;\n    this.roomId = null;\n    this.onDataReceived = null;\n    this.onConnectionStateChange = null;\n\n    // Use Google's STUN servers for NAT traversal\n    this.iceServers = [{\n      urls: 'stun:stun.l.google.com:19302'\n    }, {\n      urls: 'stun:stun1.l.google.com:19302'\n    }, {\n      urls: 'stun:stun2.l.google.com:19302'\n    }];\n  }\n  async initialize(roomId, isHost = false) {\n    this.roomId = roomId;\n    this.isHost = isHost;\n    try {\n      // Create RTCPeerConnection with optimized configuration\n      this.localConnection = new RTCPeerConnection({\n        iceServers: this.iceServers,\n        iceCandidatePoolSize: 10,\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require'\n      });\n\n      // Set up connection state monitoring\n      this.localConnection.onconnectionstatechange = () => {\n        console.log('Connection state:', this.localConnection.connectionState);\n        if (this.onConnectionStateChange) {\n          this.onConnectionStateChange(this.localConnection.connectionState === 'connected');\n        }\n      };\n      if (isHost) {\n        await this.setupAsHost();\n      } else {\n        await this.setupAsGuest();\n      }\n    } catch (error) {\n      console.error('WebRTC initialization failed:', error);\n      throw error;\n    }\n  }\n  async setupAsHost() {\n    // Create data channel with optimized settings\n    this.dataChannel = this.localConnection.createDataChannel('whiteboard', {\n      ordered: true,\n      // Ensure drawing data arrives in order\n      maxRetransmits: 3\n    });\n    this.setupDataChannel(this.dataChannel);\n\n    // Create offer\n    const offer = await this.localConnection.createOffer();\n    await this.localConnection.setLocalDescription(offer);\n\n    // In a real app, you'd send this offer through a signaling server\n    // For demo purposes, we'll use localStorage and polling\n    localStorage.setItem(`offer_${this.roomId}`, JSON.stringify({\n      offer: offer,\n      timestamp: Date.now()\n    }));\n\n    // Listen for answer\n    this.waitForAnswer();\n\n    // Handle ICE candidates\n    this.localConnection.onicecandidate = event => {\n      if (event.candidate) {\n        this.storeIceCandidate(event.candidate, 'host');\n      }\n    };\n    console.log('Host setup complete. Room ID:', this.roomId);\n    console.log('Share this Room ID with the other person to connect.');\n  }\n  async setupAsGuest() {\n    // Wait for offer\n    const offerData = await this.waitForOffer();\n    if (!offerData) {\n      throw new Error('No offer found for this room');\n    }\n    await this.localConnection.setRemoteDescription(offerData.offer);\n\n    // Listen for data channel\n    this.localConnection.ondatachannel = event => {\n      this.dataChannel = event.channel;\n      this.setupDataChannel(this.dataChannel);\n    };\n\n    // Create answer\n    const answer = await this.localConnection.createAnswer();\n    await this.localConnection.setLocalDescription(answer);\n\n    // Store answer\n    localStorage.setItem(`answer_${this.roomId}`, JSON.stringify({\n      answer: answer,\n      timestamp: Date.now()\n    }));\n\n    // Handle ICE candidates\n    this.localConnection.onicecandidate = event => {\n      if (event.candidate) {\n        this.storeIceCandidate(event.candidate, 'guest');\n      }\n    };\n\n    // Process stored ICE candidates\n    this.processStoredIceCandidates('host');\n    console.log('Guest setup complete');\n  }\n  setupDataChannel(channel) {\n    channel.onopen = () => {\n      console.log('Data channel opened');\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(true);\n      }\n    };\n    channel.onclose = () => {\n      console.log('Data channel closed');\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(false);\n      }\n    };\n    channel.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        if (this.onDataReceived) {\n          this.onDataReceived(data);\n        }\n      } catch (error) {\n        console.error('Failed to parse received data:', error);\n      }\n    };\n    channel.onerror = error => {\n      console.error('Data channel error:', error);\n    };\n  }\n  async waitForOffer() {\n    return new Promise(resolve => {\n      const checkForOffer = () => {\n        const offerData = localStorage.getItem(`offer_${this.roomId}`);\n        if (offerData) {\n          try {\n            const parsed = JSON.parse(offerData);\n            // Check if offer is not too old (5 minutes)\n            if (Date.now() - parsed.timestamp < 300000) {\n              resolve(parsed);\n              return;\n            }\n          } catch (error) {\n            console.error('Failed to parse offer:', error);\n          }\n        }\n        setTimeout(checkForOffer, 1000);\n      };\n      checkForOffer();\n    });\n  }\n  async waitForAnswer() {\n    const checkForAnswer = async () => {\n      const answerData = localStorage.getItem(`answer_${this.roomId}`);\n      if (answerData) {\n        try {\n          const parsed = JSON.parse(answerData);\n          await this.localConnection.setRemoteDescription(parsed.answer);\n          this.processStoredIceCandidates('guest');\n          console.log('Answer received and set');\n          return;\n        } catch (error) {\n          console.error('Failed to set remote description:', error);\n        }\n      }\n      setTimeout(checkForAnswer, 1000);\n    };\n    checkForAnswer();\n  }\n  storeIceCandidate(candidate, role) {\n    const key = `ice_${this.roomId}_${role}`;\n    const existing = JSON.parse(localStorage.getItem(key) || '[]');\n    existing.push({\n      candidate: candidate,\n      timestamp: Date.now()\n    });\n    localStorage.setItem(key, JSON.stringify(existing));\n  }\n  async processStoredIceCandidates(role) {\n    const key = `ice_${this.roomId}_${role}`;\n    const candidates = JSON.parse(localStorage.getItem(key) || '[]');\n    for (const candidateData of candidates) {\n      try {\n        await this.localConnection.addIceCandidate(candidateData.candidate);\n      } catch (error) {\n        console.error('Failed to add ICE candidate:', error);\n      }\n    }\n\n    // Continue polling for new candidates\n    setTimeout(() => {\n      this.processStoredIceCandidates(role);\n    }, 2000);\n  }\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      try {\n        this.dataChannel.send(JSON.stringify(data));\n      } catch (error) {\n        console.error('Failed to send data:', error);\n      }\n    }\n  }\n  disconnect() {\n    if (this.dataChannel) {\n      this.dataChannel.close();\n    }\n    if (this.localConnection) {\n      this.localConnection.close();\n    }\n\n    // Clean up localStorage\n    if (this.roomId) {\n      localStorage.removeItem(`offer_${this.roomId}`);\n      localStorage.removeItem(`answer_${this.roomId}`);\n      localStorage.removeItem(`ice_${this.roomId}_host`);\n      localStorage.removeItem(`ice_${this.roomId}_guest`);\n    }\n  }\n}\nexport default WebRTCManager;","map":{"version":3,"names":["WebRTCManager","constructor","localConnection","dataChannel","isHost","roomId","onDataReceived","onConnectionStateChange","iceServers","urls","initialize","RTCPeerConnection","iceCandidatePoolSize","bundlePolicy","rtcpMuxPolicy","onconnectionstatechange","console","log","connectionState","setupAsHost","setupAsGuest","error","createDataChannel","ordered","maxRetransmits","setupDataChannel","offer","createOffer","setLocalDescription","localStorage","setItem","JSON","stringify","timestamp","Date","now","waitForAnswer","onicecandidate","event","candidate","storeIceCandidate","offerData","waitForOffer","Error","setRemoteDescription","ondatachannel","channel","answer","createAnswer","processStoredIceCandidates","onopen","onclose","onmessage","data","parse","onerror","Promise","resolve","checkForOffer","getItem","parsed","setTimeout","checkForAnswer","answerData","role","key","existing","push","candidates","candidateData","addIceCandidate","sendData","readyState","send","disconnect","close","removeItem"],"sources":["C:/Users/eniac/Desktop/wrtc/src/services/WebRTCManager.js"],"sourcesContent":["class WebRTCManager {\n  constructor() {\n    this.localConnection = null;\n    this.dataChannel = null;\n    this.isHost = false;\n    this.roomId = null;\n    this.onDataReceived = null;\n    this.onConnectionStateChange = null;\n    \n    // Use Google's STUN servers for NAT traversal\n    this.iceServers = [\n      { urls: 'stun:stun.l.google.com:19302' },\n      { urls: 'stun:stun1.l.google.com:19302' },\n      { urls: 'stun:stun2.l.google.com:19302' }\n    ];\n  }\n\n  async initialize(roomId, isHost = false) {\n    this.roomId = roomId;\n    this.isHost = isHost;\n    \n    try {\n      // Create RTCPeerConnection with optimized configuration\n      this.localConnection = new RTCPeerConnection({\n        iceServers: this.iceServers,\n        iceCandidatePoolSize: 10,\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require'\n      });\n\n      // Set up connection state monitoring\n      this.localConnection.onconnectionstatechange = () => {\n        console.log('Connection state:', this.localConnection.connectionState);\n        if (this.onConnectionStateChange) {\n          this.onConnectionStateChange(this.localConnection.connectionState === 'connected');\n        }\n      };\n\n      if (isHost) {\n        await this.setupAsHost();\n      } else {\n        await this.setupAsGuest();\n      }\n    } catch (error) {\n      console.error('WebRTC initialization failed:', error);\n      throw error;\n    }\n  }\n\n  async setupAsHost() {\n    // Create data channel with optimized settings\n    this.dataChannel = this.localConnection.createDataChannel('whiteboard', {\n      ordered: true,  // Ensure drawing data arrives in order\n      maxRetransmits: 3\n    });\n    \n    this.setupDataChannel(this.dataChannel);\n    \n    // Create offer\n    const offer = await this.localConnection.createOffer();\n    await this.localConnection.setLocalDescription(offer);\n    \n    // In a real app, you'd send this offer through a signaling server\n    // For demo purposes, we'll use localStorage and polling\n    localStorage.setItem(`offer_${this.roomId}`, JSON.stringify({\n      offer: offer,\n      timestamp: Date.now()\n    }));\n    \n    // Listen for answer\n    this.waitForAnswer();\n    \n    // Handle ICE candidates\n    this.localConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        this.storeIceCandidate(event.candidate, 'host');\n      }\n    };\n    \n    console.log('Host setup complete. Room ID:', this.roomId);\n    console.log('Share this Room ID with the other person to connect.');\n  }\n\n  async setupAsGuest() {\n    // Wait for offer\n    const offerData = await this.waitForOffer();\n    if (!offerData) {\n      throw new Error('No offer found for this room');\n    }\n    \n    await this.localConnection.setRemoteDescription(offerData.offer);\n    \n    // Listen for data channel\n    this.localConnection.ondatachannel = (event) => {\n      this.dataChannel = event.channel;\n      this.setupDataChannel(this.dataChannel);\n    };\n    \n    // Create answer\n    const answer = await this.localConnection.createAnswer();\n    await this.localConnection.setLocalDescription(answer);\n    \n    // Store answer\n    localStorage.setItem(`answer_${this.roomId}`, JSON.stringify({\n      answer: answer,\n      timestamp: Date.now()\n    }));\n    \n    // Handle ICE candidates\n    this.localConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        this.storeIceCandidate(event.candidate, 'guest');\n      }\n    };\n    \n    // Process stored ICE candidates\n    this.processStoredIceCandidates('host');\n    \n    console.log('Guest setup complete');\n  }\n\n  setupDataChannel(channel) {\n    channel.onopen = () => {\n      console.log('Data channel opened');\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(true);\n      }\n    };\n    \n    channel.onclose = () => {\n      console.log('Data channel closed');\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(false);\n      }\n    };\n    \n    channel.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        if (this.onDataReceived) {\n          this.onDataReceived(data);\n        }\n      } catch (error) {\n        console.error('Failed to parse received data:', error);\n      }\n    };\n    \n    channel.onerror = (error) => {\n      console.error('Data channel error:', error);\n    };\n  }\n\n  async waitForOffer() {\n    return new Promise((resolve) => {\n      const checkForOffer = () => {\n        const offerData = localStorage.getItem(`offer_${this.roomId}`);\n        if (offerData) {\n          try {\n            const parsed = JSON.parse(offerData);\n            // Check if offer is not too old (5 minutes)\n            if (Date.now() - parsed.timestamp < 300000) {\n              resolve(parsed);\n              return;\n            }\n          } catch (error) {\n            console.error('Failed to parse offer:', error);\n          }\n        }\n        setTimeout(checkForOffer, 1000);\n      };\n      checkForOffer();\n    });\n  }\n\n  async waitForAnswer() {\n    const checkForAnswer = async () => {\n      const answerData = localStorage.getItem(`answer_${this.roomId}`);\n      if (answerData) {\n        try {\n          const parsed = JSON.parse(answerData);\n          await this.localConnection.setRemoteDescription(parsed.answer);\n          this.processStoredIceCandidates('guest');\n          console.log('Answer received and set');\n          return;\n        } catch (error) {\n          console.error('Failed to set remote description:', error);\n        }\n      }\n      setTimeout(checkForAnswer, 1000);\n    };\n    checkForAnswer();\n  }\n\n  storeIceCandidate(candidate, role) {\n    const key = `ice_${this.roomId}_${role}`;\n    const existing = JSON.parse(localStorage.getItem(key) || '[]');\n    existing.push({\n      candidate: candidate,\n      timestamp: Date.now()\n    });\n    localStorage.setItem(key, JSON.stringify(existing));\n  }\n\n  async processStoredIceCandidates(role) {\n    const key = `ice_${this.roomId}_${role}`;\n    const candidates = JSON.parse(localStorage.getItem(key) || '[]');\n    \n    for (const candidateData of candidates) {\n      try {\n        await this.localConnection.addIceCandidate(candidateData.candidate);\n      } catch (error) {\n        console.error('Failed to add ICE candidate:', error);\n      }\n    }\n    \n    // Continue polling for new candidates\n    setTimeout(() => {\n      this.processStoredIceCandidates(role);\n    }, 2000);\n  }\n\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      try {\n        this.dataChannel.send(JSON.stringify(data));\n      } catch (error) {\n        console.error('Failed to send data:', error);\n      }\n    }\n  }\n\n  disconnect() {\n    if (this.dataChannel) {\n      this.dataChannel.close();\n    }\n    if (this.localConnection) {\n      this.localConnection.close();\n    }\n    \n    // Clean up localStorage\n    if (this.roomId) {\n      localStorage.removeItem(`offer_${this.roomId}`);\n      localStorage.removeItem(`answer_${this.roomId}`);\n      localStorage.removeItem(`ice_${this.roomId}_host`);\n      localStorage.removeItem(`ice_${this.roomId}_guest`);\n    }\n  }\n}\n\nexport default WebRTCManager; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}