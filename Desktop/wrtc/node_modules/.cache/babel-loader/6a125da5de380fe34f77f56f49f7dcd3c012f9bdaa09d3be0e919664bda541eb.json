{"ast":null,"code":"import { io } from 'socket.io-client';\nclass WebRTCManager {\n  constructor() {\n    this.peerConnection = null;\n    this.dataChannel = null;\n    this.socket = null;\n    this.roomId = null;\n    this.isHost = false;\n    this.onConnectionStateChange = null;\n    this.onDataReceived = null;\n    this.onDebugLog = null;\n    this.connectionTimeout = null;\n\n    // WebRTC configuration with STUN servers\n    this.config = {\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }, {\n        urls: 'stun:stun2.l.google.com:19302'\n      }],\n      iceCandidatePoolSize: 10\n    };\n  }\n\n  // Connect to signaling server\n  connectToSignalingServer() {\n    this.debugLog('üîó Connecting to signaling server...');\n\n    // Use HTTP for signaling server for better WebSocket compatibility\n    // Even if main app is HTTPS, signaling can use HTTP in development\n    const currentHost = window.location.hostname;\n    const signalingUrl = `http://${currentHost}:3001`;\n    this.debugLog(`üì° Signaling server URL: ${signalingUrl}`);\n    this.debugLog(`üåç Current page: ${window.location.href}`);\n    this.debugLog(`üí° Using HTTP signaling for better compatibility`);\n    this.socket = io(signalingUrl, {\n      transports: ['websocket', 'polling'],\n      timeout: 20000,\n      forceNew: true,\n      upgrade: true,\n      rememberUpgrade: false\n    });\n    this.socket.on('connect', () => {\n      this.debugLog('‚úÖ Connected to signaling server');\n    });\n    this.socket.on('disconnect', reason => {\n      this.debugLog(`‚ùå Disconnected from signaling server: ${reason}`);\n    });\n    this.socket.on('connect_error', error => {\n      this.debugLog(`‚ùå Connection error: ${error.message}`);\n      this.debugLog(`üîß Trying to connect to: ${signalingUrl}`);\n\n      // Provide helpful troubleshooting info\n      this.debugLog('üí° Signaling server uses HTTP for better WebSocket compatibility');\n    });\n\n    // Listen for WebRTC signaling events\n    this.setupSignalingListeners();\n  }\n  setupSignalingListeners() {\n    // Handle incoming offer\n    this.socket.on('webrtc-offer', async data => {\n      this.debugLog('üì• Received WebRTC offer');\n      this.debugLog(`üìã Offer details: ${JSON.stringify(data.offer).substring(0, 100)}...`);\n      try {\n        await this.handleOffer(data.offer);\n        this.debugLog('‚úÖ Processed offer and sent answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      }\n    });\n\n    // Handle incoming answer\n    this.socket.on('webrtc-answer', async data => {\n      this.debugLog('üì• Received WebRTC answer');\n      this.debugLog(`üìã Answer details: ${JSON.stringify(data.answer).substring(0, 100)}...`);\n      try {\n        await this.handleAnswer(data.answer);\n        this.debugLog('‚úÖ Processed answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      }\n    });\n\n    // Handle ICE candidates\n    this.socket.on('webrtc-ice-candidate', async data => {\n      var _data$candidate;\n      this.debugLog('üßä Received ICE candidate');\n      this.debugLog(`üîç ICE candidate type: ${((_data$candidate = data.candidate) === null || _data$candidate === void 0 ? void 0 : _data$candidate.type) || 'unknown'}`);\n      try {\n        await this.handleIceCandidate(data.candidate);\n        this.debugLog('‚úÖ ICE candidate added successfully');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling ICE candidate: ${error.message}`);\n      }\n    });\n\n    // Handle call initiation (for host)\n    this.socket.on('start-call', async () => {\n      try {\n        this.debugLog('üöÄ Starting call as host');\n        this.debugLog('üîß About to create WebRTC offer...');\n\n        // Check if peer connection exists\n        if (!this.peerConnection) {\n          this.debugLog('‚ùå No peer connection - reinitializing...');\n          this.initializePeerConnection();\n        }\n        await this.createOffer();\n        this.debugLog('‚úÖ Offer creation completed');\n      } catch (error) {\n        this.debugLog(`‚ùå CRITICAL ERROR in start-call: ${error.message}`);\n        this.debugLog(`‚ùå Error stack: ${error.stack}`);\n        console.error('WebRTC start-call error:', error);\n      }\n    });\n\n    // Handle user events\n    this.socket.on('user-joined', data => {\n      this.debugLog(`üëã User joined room (${data.participantCount} total)`);\n    });\n    this.socket.on('user-left', data => {\n      this.debugLog(`üëã User left room (${data.participantCount} remaining)`);\n      if (data.participantCount === 0) {\n        this.cleanup();\n      }\n    });\n  }\n\n  // Join or create a room\n  async joinRoom(roomId) {\n    if (!this.socket) {\n      this.connectToSignalingServer();\n      await new Promise(resolve => {\n        this.socket.on('connect', resolve);\n      });\n    }\n    return new Promise((resolve, reject) => {\n      this.roomId = roomId;\n      this.socket.emit('join-room', roomId, response => {\n        if (response.success) {\n          this.isHost = response.isHost;\n          this.debugLog(`‚úÖ Joined room as ${this.isHost ? 'HOST' : 'GUEST'}`);\n          this.debugLog(`üë• Participants: ${response.participantCount}/2`);\n\n          // Initialize WebRTC\n          this.initializePeerConnection();\n          resolve({\n            success: true,\n            isHost: this.isHost,\n            participantCount: response.participantCount\n          });\n        } else {\n          this.debugLog(`‚ùå Failed to join room: ${response.message}`);\n          reject(new Error(response.message));\n        }\n      });\n    });\n  }\n  initializePeerConnection() {\n    this.debugLog('üîÑ Initializing peer connection...');\n    this.peerConnection = new RTCPeerConnection(this.config);\n\n    // Create data channel (host only)\n    if (this.isHost) {\n      this.dataChannel = this.peerConnection.createDataChannel('whiteboard', {\n        ordered: true\n      });\n      this.setupDataChannel();\n      this.debugLog('üì∫ Data channel created (host)');\n    }\n\n    // Handle incoming data channel (guest)\n    this.peerConnection.ondatachannel = event => {\n      this.debugLog('üì∫ Data channel received (guest)');\n      this.dataChannel = event.channel;\n      this.setupDataChannel();\n    };\n\n    // Handle ICE candidates\n    this.peerConnection.onicecandidate = event => {\n      if (event.candidate) {\n        this.debugLog('üßä Sending ICE candidate');\n        this.socket.emit('webrtc-ice-candidate', {\n          candidate: event.candidate\n        });\n      }\n    };\n\n    // Monitor connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      const state = this.peerConnection.connectionState;\n      this.debugLog(`üîÑ Connection state: ${state}`);\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(state);\n      }\n      if (state === 'connected') {\n        this.debugLog('üéâ WebRTC connection established!');\n        if (this.connectionTimeout) {\n          clearTimeout(this.connectionTimeout);\n        }\n      } else if (state === 'failed' || state === 'disconnected') {\n        this.debugLog('‚ùå Connection failed or disconnected');\n        this.cleanup();\n      }\n    };\n\n    // Monitor ICE connection state\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const iceState = this.peerConnection.iceConnectionState;\n      this.debugLog(`üßä ICE connection state: ${iceState}`);\n    };\n\n    // Monitor signaling state\n    this.peerConnection.onsignalingstatechange = () => {\n      const signalingState = this.peerConnection.signalingState;\n      this.debugLog(`üì° Signaling state: ${signalingState}`);\n    };\n\n    // Set connection timeout\n    this.connectionTimeout = setTimeout(() => {\n      var _this$peerConnection;\n      if (((_this$peerConnection = this.peerConnection) === null || _this$peerConnection === void 0 ? void 0 : _this$peerConnection.connectionState) !== 'connected') {\n        var _this$peerConnection2, _this$peerConnection3, _this$peerConnection4;\n        this.debugLog('‚è∞ Connection timeout - cleaning up');\n        this.debugLog(`üîç Final states - Connection: ${(_this$peerConnection2 = this.peerConnection) === null || _this$peerConnection2 === void 0 ? void 0 : _this$peerConnection2.connectionState}, ICE: ${(_this$peerConnection3 = this.peerConnection) === null || _this$peerConnection3 === void 0 ? void 0 : _this$peerConnection3.iceConnectionState}, Signaling: ${(_this$peerConnection4 = this.peerConnection) === null || _this$peerConnection4 === void 0 ? void 0 : _this$peerConnection4.signalingState}`);\n        this.cleanup();\n      }\n    }, 30000); // 30 second timeout\n  }\n  setupDataChannel() {\n    this.dataChannel.onopen = () => {\n      this.debugLog('üì∫ Data channel opened');\n    };\n    this.dataChannel.onclose = () => {\n      this.debugLog('üì∫ Data channel closed');\n    };\n    this.dataChannel.onmessage = event => {\n      if (this.onDataReceived) {\n        const data = JSON.parse(event.data);\n        this.onDataReceived(data);\n      }\n    };\n    this.dataChannel.onerror = error => {\n      this.debugLog(`‚ùå Data channel error: ${error}`);\n    };\n  }\n  async createOffer() {\n    try {\n      this.debugLog('üì§ Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n      await this.peerConnection.setLocalDescription(offer);\n      this.socket.emit('webrtc-offer', {\n        offer\n      });\n      this.debugLog('üì§ Offer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error creating offer: ${error.message}`);\n      throw error;\n    }\n  }\n  async handleOffer(offer) {\n    try {\n      await this.peerConnection.setRemoteDescription(offer);\n      const answer = await this.peerConnection.createAnswer();\n      await this.peerConnection.setLocalDescription(answer);\n      this.socket.emit('webrtc-answer', {\n        answer\n      });\n      this.debugLog('üì§ Answer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      throw error;\n    }\n  }\n  async handleAnswer(answer) {\n    try {\n      await this.peerConnection.setRemoteDescription(answer);\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      throw error;\n    }\n  }\n  async handleIceCandidate(candidate) {\n    try {\n      await this.peerConnection.addIceCandidate(candidate);\n    } catch (error) {\n      this.debugLog(`‚ùå Error adding ICE candidate: ${error.message}`);\n    }\n  }\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      this.dataChannel.send(JSON.stringify(data));\n      return true;\n    }\n    return false;\n  }\n  getConnectionState() {\n    var _this$peerConnection5;\n    return ((_this$peerConnection5 = this.peerConnection) === null || _this$peerConnection5 === void 0 ? void 0 : _this$peerConnection5.connectionState) || 'new';\n  }\n  cleanup() {\n    this.debugLog('üßπ Cleaning up WebRTC connection...');\n    if (this.connectionTimeout) {\n      clearTimeout(this.connectionTimeout);\n    }\n    if (this.dataChannel) {\n      this.dataChannel.close();\n      this.dataChannel = null;\n    }\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    this.roomId = null;\n    this.isHost = false;\n  }\n  debugLog(message) {\n    console.log(`[WebRTC] ${message}`);\n    if (this.onDebugLog) {\n      this.onDebugLog(message);\n    }\n  }\n}\nexport default WebRTCManager;","map":{"version":3,"names":["io","WebRTCManager","constructor","peerConnection","dataChannel","socket","roomId","isHost","onConnectionStateChange","onDataReceived","onDebugLog","connectionTimeout","config","iceServers","urls","iceCandidatePoolSize","connectToSignalingServer","debugLog","currentHost","window","location","hostname","signalingUrl","href","transports","timeout","forceNew","upgrade","rememberUpgrade","on","reason","error","message","setupSignalingListeners","data","JSON","stringify","offer","substring","handleOffer","answer","handleAnswer","_data$candidate","candidate","type","handleIceCandidate","initializePeerConnection","createOffer","stack","console","participantCount","cleanup","joinRoom","Promise","resolve","reject","emit","response","success","Error","RTCPeerConnection","createDataChannel","ordered","setupDataChannel","ondatachannel","event","channel","onicecandidate","onconnectionstatechange","state","connectionState","clearTimeout","oniceconnectionstatechange","iceState","iceConnectionState","onsignalingstatechange","signalingState","setTimeout","_this$peerConnection","_this$peerConnection2","_this$peerConnection3","_this$peerConnection4","onopen","onclose","onmessage","parse","onerror","setLocalDescription","setRemoteDescription","createAnswer","addIceCandidate","sendData","readyState","send","getConnectionState","_this$peerConnection5","close","disconnect","log"],"sources":["C:/Users/eniac/Desktop/wrtc/src/services/WebRTCManager.js"],"sourcesContent":["import { io } from 'socket.io-client';\n\nclass WebRTCManager {\n  constructor() {\n    this.peerConnection = null;\n    this.dataChannel = null;\n    this.socket = null;\n    this.roomId = null;\n    this.isHost = false;\n    this.onConnectionStateChange = null;\n    this.onDataReceived = null;\n    this.onDebugLog = null;\n    this.connectionTimeout = null;\n    \n    // WebRTC configuration with STUN servers\n    this.config = {\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n        { urls: 'stun:stun2.l.google.com:19302' }\n      ],\n      iceCandidatePoolSize: 10\n    };\n  }\n\n  // Connect to signaling server\n  connectToSignalingServer() {\n    this.debugLog('üîó Connecting to signaling server...');\n    \n    // Use HTTP for signaling server for better WebSocket compatibility\n    // Even if main app is HTTPS, signaling can use HTTP in development\n    const currentHost = window.location.hostname;\n    const signalingUrl = `http://${currentHost}:3001`;\n    \n    this.debugLog(`üì° Signaling server URL: ${signalingUrl}`);\n    this.debugLog(`üåç Current page: ${window.location.href}`);\n    this.debugLog(`üí° Using HTTP signaling for better compatibility`);\n    \n    this.socket = io(signalingUrl, {\n      transports: ['websocket', 'polling'],\n      timeout: 20000,\n      forceNew: true,\n      upgrade: true,\n      rememberUpgrade: false\n    });\n\n    this.socket.on('connect', () => {\n      this.debugLog('‚úÖ Connected to signaling server');\n    });\n\n    this.socket.on('disconnect', (reason) => {\n      this.debugLog(`‚ùå Disconnected from signaling server: ${reason}`);\n    });\n\n    this.socket.on('connect_error', (error) => {\n      this.debugLog(`‚ùå Connection error: ${error.message}`);\n      this.debugLog(`üîß Trying to connect to: ${signalingUrl}`);\n      \n      // Provide helpful troubleshooting info\n      this.debugLog('üí° Signaling server uses HTTP for better WebSocket compatibility');\n    });\n\n    // Listen for WebRTC signaling events\n    this.setupSignalingListeners();\n  }\n\n  setupSignalingListeners() {\n    // Handle incoming offer\n    this.socket.on('webrtc-offer', async (data) => {\n      this.debugLog('üì• Received WebRTC offer');\n      this.debugLog(`üìã Offer details: ${JSON.stringify(data.offer).substring(0, 100)}...`);\n      try {\n        await this.handleOffer(data.offer);\n        this.debugLog('‚úÖ Processed offer and sent answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      }\n    });\n\n    // Handle incoming answer\n    this.socket.on('webrtc-answer', async (data) => {\n      this.debugLog('üì• Received WebRTC answer');\n      this.debugLog(`üìã Answer details: ${JSON.stringify(data.answer).substring(0, 100)}...`);\n      try {\n        await this.handleAnswer(data.answer);\n        this.debugLog('‚úÖ Processed answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      }\n    });\n\n    // Handle ICE candidates\n    this.socket.on('webrtc-ice-candidate', async (data) => {\n      this.debugLog('üßä Received ICE candidate');\n      this.debugLog(`üîç ICE candidate type: ${data.candidate?.type || 'unknown'}`);\n      try {\n        await this.handleIceCandidate(data.candidate);\n        this.debugLog('‚úÖ ICE candidate added successfully');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling ICE candidate: ${error.message}`);\n      }\n    });\n\n    // Handle call initiation (for host)\n    this.socket.on('start-call', async () => {\n      try {\n        this.debugLog('üöÄ Starting call as host');\n        this.debugLog('üîß About to create WebRTC offer...');\n        \n        // Check if peer connection exists\n        if (!this.peerConnection) {\n          this.debugLog('‚ùå No peer connection - reinitializing...');\n          this.initializePeerConnection();\n        }\n        \n        await this.createOffer();\n        this.debugLog('‚úÖ Offer creation completed');\n      } catch (error) {\n        this.debugLog(`‚ùå CRITICAL ERROR in start-call: ${error.message}`);\n        this.debugLog(`‚ùå Error stack: ${error.stack}`);\n        console.error('WebRTC start-call error:', error);\n      }\n    });\n\n    // Handle user events\n    this.socket.on('user-joined', (data) => {\n      this.debugLog(`üëã User joined room (${data.participantCount} total)`);\n    });\n\n    this.socket.on('user-left', (data) => {\n      this.debugLog(`üëã User left room (${data.participantCount} remaining)`);\n      if (data.participantCount === 0) {\n        this.cleanup();\n      }\n    });\n  }\n\n  // Join or create a room\n  async joinRoom(roomId) {\n    if (!this.socket) {\n      this.connectToSignalingServer();\n      await new Promise(resolve => {\n        this.socket.on('connect', resolve);\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      this.roomId = roomId;\n      \n      this.socket.emit('join-room', roomId, (response) => {\n        if (response.success) {\n          this.isHost = response.isHost;\n          this.debugLog(`‚úÖ Joined room as ${this.isHost ? 'HOST' : 'GUEST'}`);\n          this.debugLog(`üë• Participants: ${response.participantCount}/2`);\n          \n          // Initialize WebRTC\n          this.initializePeerConnection();\n          \n          resolve({\n            success: true,\n            isHost: this.isHost,\n            participantCount: response.participantCount\n          });\n        } else {\n          this.debugLog(`‚ùå Failed to join room: ${response.message}`);\n          reject(new Error(response.message));\n        }\n      });\n    });\n  }\n\n  initializePeerConnection() {\n    this.debugLog('üîÑ Initializing peer connection...');\n    \n    this.peerConnection = new RTCPeerConnection(this.config);\n\n    // Create data channel (host only)\n    if (this.isHost) {\n      this.dataChannel = this.peerConnection.createDataChannel('whiteboard', {\n        ordered: true\n      });\n      this.setupDataChannel();\n      this.debugLog('üì∫ Data channel created (host)');\n    }\n\n    // Handle incoming data channel (guest)\n    this.peerConnection.ondatachannel = (event) => {\n      this.debugLog('üì∫ Data channel received (guest)');\n      this.dataChannel = event.channel;\n      this.setupDataChannel();\n    };\n\n    // Handle ICE candidates\n    this.peerConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        this.debugLog('üßä Sending ICE candidate');\n        this.socket.emit('webrtc-ice-candidate', {\n          candidate: event.candidate\n        });\n      }\n    };\n\n    // Monitor connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      const state = this.peerConnection.connectionState;\n      this.debugLog(`üîÑ Connection state: ${state}`);\n      \n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(state);\n      }\n\n      if (state === 'connected') {\n        this.debugLog('üéâ WebRTC connection established!');\n        if (this.connectionTimeout) {\n          clearTimeout(this.connectionTimeout);\n        }\n      } else if (state === 'failed' || state === 'disconnected') {\n        this.debugLog('‚ùå Connection failed or disconnected');\n        this.cleanup();\n      }\n    };\n\n    // Monitor ICE connection state\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const iceState = this.peerConnection.iceConnectionState;\n      this.debugLog(`üßä ICE connection state: ${iceState}`);\n    };\n\n    // Monitor signaling state\n    this.peerConnection.onsignalingstatechange = () => {\n      const signalingState = this.peerConnection.signalingState;\n      this.debugLog(`üì° Signaling state: ${signalingState}`);\n    };\n\n    // Set connection timeout\n    this.connectionTimeout = setTimeout(() => {\n      if (this.peerConnection?.connectionState !== 'connected') {\n        this.debugLog('‚è∞ Connection timeout - cleaning up');\n        this.debugLog(`üîç Final states - Connection: ${this.peerConnection?.connectionState}, ICE: ${this.peerConnection?.iceConnectionState}, Signaling: ${this.peerConnection?.signalingState}`);\n        this.cleanup();\n      }\n    }, 30000); // 30 second timeout\n  }\n\n  setupDataChannel() {\n    this.dataChannel.onopen = () => {\n      this.debugLog('üì∫ Data channel opened');\n    };\n\n    this.dataChannel.onclose = () => {\n      this.debugLog('üì∫ Data channel closed');\n    };\n\n    this.dataChannel.onmessage = (event) => {\n      if (this.onDataReceived) {\n        const data = JSON.parse(event.data);\n        this.onDataReceived(data);\n      }\n    };\n\n    this.dataChannel.onerror = (error) => {\n      this.debugLog(`‚ùå Data channel error: ${error}`);\n    };\n  }\n\n  async createOffer() {\n    try {\n      this.debugLog('üì§ Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n      await this.peerConnection.setLocalDescription(offer);\n      \n      this.socket.emit('webrtc-offer', { offer });\n      this.debugLog('üì§ Offer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error creating offer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async handleOffer(offer) {\n    try {\n      await this.peerConnection.setRemoteDescription(offer);\n      const answer = await this.peerConnection.createAnswer();\n      await this.peerConnection.setLocalDescription(answer);\n      \n      this.socket.emit('webrtc-answer', { answer });\n      this.debugLog('üì§ Answer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async handleAnswer(answer) {\n    try {\n      await this.peerConnection.setRemoteDescription(answer);\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async handleIceCandidate(candidate) {\n    try {\n      await this.peerConnection.addIceCandidate(candidate);\n    } catch (error) {\n      this.debugLog(`‚ùå Error adding ICE candidate: ${error.message}`);\n    }\n  }\n\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      this.dataChannel.send(JSON.stringify(data));\n      return true;\n    }\n    return false;\n  }\n\n  getConnectionState() {\n    return this.peerConnection?.connectionState || 'new';\n  }\n\n  cleanup() {\n    this.debugLog('üßπ Cleaning up WebRTC connection...');\n    \n    if (this.connectionTimeout) {\n      clearTimeout(this.connectionTimeout);\n    }\n\n    if (this.dataChannel) {\n      this.dataChannel.close();\n      this.dataChannel = null;\n    }\n\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n\n    this.roomId = null;\n    this.isHost = false;\n  }\n\n  debugLog(message) {\n    console.log(`[WebRTC] ${message}`);\n    if (this.onDebugLog) {\n      this.onDebugLog(message);\n    }\n  }\n}\n\nexport default WebRTCManager; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}