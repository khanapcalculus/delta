{"ast":null,"code":"import { io } from 'socket.io-client';\nclass WebRTCManager {\n  constructor() {\n    this.peerConnection = null;\n    this.dataChannel = null;\n    this.socket = null;\n    this.roomId = null;\n    this.isHost = false;\n    this.onConnectionStateChange = null;\n    this.onDataReceived = null;\n    this.onDebugLog = null;\n    this.connectionTimeout = null;\n\n    // WebRTC configuration with STUN servers\n    this.config = {\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }, {\n        urls: 'stun:stun2.l.google.com:19302'\n      }],\n      iceCandidatePoolSize: 10\n    };\n  }\n\n  // Connect to signaling server\n  connectToSignalingServer() {\n    this.debugLog('üîó Connecting to signaling server...');\n\n    // Use HTTP for signaling server for better WebSocket compatibility\n    // Even if main app is HTTPS, signaling can use HTTP in development\n    const currentHost = window.location.hostname;\n    const signalingUrl = `http://${currentHost}:3001`;\n    this.debugLog(`üì° Signaling server URL: ${signalingUrl}`);\n    this.debugLog(`üåç Current page: ${window.location.href}`);\n    this.debugLog(`üí° Using HTTP signaling for better compatibility`);\n    this.socket = io(signalingUrl, {\n      transports: ['websocket', 'polling'],\n      timeout: 20000,\n      forceNew: true,\n      upgrade: true,\n      rememberUpgrade: false\n    });\n    this.socket.on('connect', () => {\n      this.debugLog('‚úÖ Connected to signaling server');\n    });\n    this.socket.on('disconnect', reason => {\n      this.debugLog(`‚ùå Disconnected from signaling server: ${reason}`);\n    });\n    this.socket.on('connect_error', error => {\n      this.debugLog(`‚ùå Connection error: ${error.message}`);\n      this.debugLog(`üîß Trying to connect to: ${signalingUrl}`);\n\n      // Provide helpful troubleshooting info\n      this.debugLog('üí° Signaling server uses HTTP for better WebSocket compatibility');\n    });\n\n    // Listen for WebRTC signaling events\n    this.setupSignalingListeners();\n  }\n  setupSignalingListeners() {\n    // Handle incoming offer\n    this.socket.on('webrtc-offer', async data => {\n      this.debugLog('üì• Received WebRTC offer');\n      this.debugLog(`üìã Offer details: ${JSON.stringify(data.offer).substring(0, 100)}...`);\n      try {\n        await this.handleOffer(data.offer);\n        this.debugLog('‚úÖ Processed offer and sent answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      }\n    });\n\n    // Handle incoming answer\n    this.socket.on('webrtc-answer', async data => {\n      this.debugLog('üì• Received WebRTC answer');\n      this.debugLog(`üìã Answer details: ${JSON.stringify(data.answer).substring(0, 100)}...`);\n      try {\n        await this.handleAnswer(data.answer);\n        this.debugLog('‚úÖ Processed answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      }\n    });\n\n    // Handle ICE candidates\n    this.socket.on('webrtc-ice-candidate', async data => {\n      var _data$candidate;\n      this.debugLog('üßä Received ICE candidate');\n      this.debugLog(`üîç ICE candidate type: ${((_data$candidate = data.candidate) === null || _data$candidate === void 0 ? void 0 : _data$candidate.type) || 'unknown'}`);\n      try {\n        await this.handleIceCandidate(data.candidate);\n        this.debugLog('‚úÖ ICE candidate added successfully');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling ICE candidate: ${error.message}`);\n      }\n    });\n\n    // Handle call initiation (for host)\n    this.socket.on('start-call', async () => {\n      this.debugLog('üöÄ Starting call as host');\n      try {\n        if (this.peerConnection && this.peerConnection.signalingState === 'stable') {\n          await this.createOffer();\n        } else {\n          this.debugLog('‚ùå Peer connection not ready, skipping offer creation');\n        }\n      } catch (error) {\n        this.debugLog(`‚ùå Error in start-call: ${error.message}`);\n      }\n    });\n\n    // Handle user events\n    this.socket.on('user-joined', data => {\n      this.debugLog(`üëã User joined room (${data.participantCount} total)`);\n    });\n    this.socket.on('user-left', data => {\n      this.debugLog(`üëã User left room (${data.participantCount} remaining)`);\n      if (data.participantCount === 0) {\n        this.cleanup();\n      }\n    });\n  }\n\n  // Join or create a room\n  async joinRoom(roomId) {\n    if (!this.socket) {\n      this.connectToSignalingServer();\n      await new Promise(resolve => {\n        this.socket.on('connect', resolve);\n      });\n    }\n    return new Promise((resolve, reject) => {\n      this.roomId = roomId;\n      this.socket.emit('join-room', roomId, response => {\n        if (response.success) {\n          this.isHost = response.isHost;\n          this.debugLog(`‚úÖ Joined room as ${this.isHost ? 'HOST' : 'GUEST'}`);\n          this.debugLog(`üë• Participants: ${response.participantCount}/2`);\n\n          // Initialize WebRTC\n          this.initializePeerConnection();\n          resolve({\n            success: true,\n            isHost: this.isHost,\n            participantCount: response.participantCount\n          });\n        } else {\n          this.debugLog(`‚ùå Failed to join room: ${response.message}`);\n          reject(new Error(response.message));\n        }\n      });\n    });\n  }\n  initializePeerConnection() {\n    this.debugLog('üîÑ Initializing peer connection...');\n    this.peerConnection = new RTCPeerConnection(this.config);\n\n    // Create data channel (host only)\n    if (this.isHost) {\n      this.dataChannel = this.peerConnection.createDataChannel('whiteboard', {\n        ordered: true\n      });\n      this.setupDataChannel();\n      this.debugLog('üì∫ Data channel created (host)');\n    }\n\n    // Handle incoming data channel (guest)\n    this.peerConnection.ondatachannel = event => {\n      this.debugLog('üì∫ Data channel received (guest)');\n      this.dataChannel = event.channel;\n      this.setupDataChannel();\n    };\n\n    // Handle ICE candidates\n    this.peerConnection.onicecandidate = event => {\n      if (event.candidate) {\n        this.debugLog('üßä Sending ICE candidate');\n        this.socket.emit('webrtc-ice-candidate', {\n          candidate: event.candidate\n        });\n      }\n    };\n\n    // Monitor connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      const state = this.peerConnection.connectionState;\n      this.debugLog(`üîÑ Connection state: ${state}`);\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(state);\n      }\n      if (state === 'connected') {\n        this.debugLog('üéâ WebRTC connection established!');\n        if (this.connectionTimeout) {\n          clearTimeout(this.connectionTimeout);\n        }\n      } else if (state === 'failed' || state === 'disconnected') {\n        this.debugLog('‚ùå Connection failed or disconnected');\n        this.cleanup();\n      }\n    };\n\n    // Monitor ICE connection state\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const iceState = this.peerConnection.iceConnectionState;\n      this.debugLog(`üßä ICE connection state: ${iceState}`);\n    };\n\n    // Monitor signaling state\n    this.peerConnection.onsignalingstatechange = () => {\n      const signalingState = this.peerConnection.signalingState;\n      this.debugLog(`üì° Signaling state: ${signalingState}`);\n    };\n\n    // Set connection timeout\n    this.connectionTimeout = setTimeout(() => {\n      var _this$peerConnection;\n      if (((_this$peerConnection = this.peerConnection) === null || _this$peerConnection === void 0 ? void 0 : _this$peerConnection.connectionState) !== 'connected') {\n        var _this$peerConnection2, _this$peerConnection3, _this$peerConnection4;\n        this.debugLog('‚è∞ Connection timeout - cleaning up');\n        this.debugLog(`üîç Final states - Connection: ${(_this$peerConnection2 = this.peerConnection) === null || _this$peerConnection2 === void 0 ? void 0 : _this$peerConnection2.connectionState}, ICE: ${(_this$peerConnection3 = this.peerConnection) === null || _this$peerConnection3 === void 0 ? void 0 : _this$peerConnection3.iceConnectionState}, Signaling: ${(_this$peerConnection4 = this.peerConnection) === null || _this$peerConnection4 === void 0 ? void 0 : _this$peerConnection4.signalingState}`);\n        this.cleanup();\n      }\n    }, 30000); // 30 second timeout\n  }\n  setupDataChannel() {\n    this.dataChannel.onopen = () => {\n      this.debugLog('üì∫ Data channel opened');\n    };\n    this.dataChannel.onclose = () => {\n      this.debugLog('üì∫ Data channel closed');\n    };\n    this.dataChannel.onmessage = event => {\n      if (this.onDataReceived) {\n        const data = JSON.parse(event.data);\n        this.onDataReceived(data);\n      }\n    };\n    this.dataChannel.onerror = error => {\n      this.debugLog(`‚ùå Data channel error: ${error}`);\n    };\n  }\n  async createOffer() {\n    try {\n      this.debugLog('üì§ Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n      await this.peerConnection.setLocalDescription(offer);\n      this.socket.emit('webrtc-offer', {\n        offer\n      });\n      this.debugLog('üì§ Offer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error creating offer: ${error.message}`);\n      throw error;\n    }\n  }\n  async handleOffer(offer) {\n    try {\n      await this.peerConnection.setRemoteDescription(offer);\n      const answer = await this.peerConnection.createAnswer();\n      await this.peerConnection.setLocalDescription(answer);\n      this.socket.emit('webrtc-answer', {\n        answer\n      });\n      this.debugLog('üì§ Answer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      throw error;\n    }\n  }\n  async handleAnswer(answer) {\n    try {\n      await this.peerConnection.setRemoteDescription(answer);\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      throw error;\n    }\n  }\n  async handleIceCandidate(candidate) {\n    try {\n      await this.peerConnection.addIceCandidate(candidate);\n    } catch (error) {\n      this.debugLog(`‚ùå Error adding ICE candidate: ${error.message}`);\n    }\n  }\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      this.dataChannel.send(JSON.stringify(data));\n      return true;\n    }\n    return false;\n  }\n  getConnectionState() {\n    var _this$peerConnection5;\n    return ((_this$peerConnection5 = this.peerConnection) === null || _this$peerConnection5 === void 0 ? void 0 : _this$peerConnection5.connectionState) || 'new';\n  }\n  cleanup() {\n    this.debugLog('üßπ Cleaning up WebRTC connection...');\n    if (this.connectionTimeout) {\n      clearTimeout(this.connectionTimeout);\n    }\n    if (this.dataChannel) {\n      this.dataChannel.close();\n      this.dataChannel = null;\n    }\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    this.roomId = null;\n    this.isHost = false;\n  }\n  debugLog(message) {\n    console.log(`[WebRTC] ${message}`);\n    if (this.onDebugLog) {\n      this.onDebugLog(message);\n    }\n  }\n}\nexport default WebRTCManager;","map":{"version":3,"names":["io","WebRTCManager","constructor","peerConnection","dataChannel","socket","roomId","isHost","onConnectionStateChange","onDataReceived","onDebugLog","connectionTimeout","config","iceServers","urls","iceCandidatePoolSize","connectToSignalingServer","debugLog","currentHost","window","location","hostname","signalingUrl","href","transports","timeout","forceNew","upgrade","rememberUpgrade","on","reason","error","message","setupSignalingListeners","data","JSON","stringify","offer","substring","handleOffer","answer","handleAnswer","_data$candidate","candidate","type","handleIceCandidate","signalingState","createOffer","participantCount","cleanup","joinRoom","Promise","resolve","reject","emit","response","success","initializePeerConnection","Error","RTCPeerConnection","createDataChannel","ordered","setupDataChannel","ondatachannel","event","channel","onicecandidate","onconnectionstatechange","state","connectionState","clearTimeout","oniceconnectionstatechange","iceState","iceConnectionState","onsignalingstatechange","setTimeout","_this$peerConnection","_this$peerConnection2","_this$peerConnection3","_this$peerConnection4","onopen","onclose","onmessage","parse","onerror","setLocalDescription","setRemoteDescription","createAnswer","addIceCandidate","sendData","readyState","send","getConnectionState","_this$peerConnection5","close","disconnect","console","log"],"sources":["C:/Users/eniac/Desktop/wrtc/src/services/WebRTCManager.js"],"sourcesContent":["import { io } from 'socket.io-client';\n\nclass WebRTCManager {\n  constructor() {\n    this.peerConnection = null;\n    this.dataChannel = null;\n    this.socket = null;\n    this.roomId = null;\n    this.isHost = false;\n    this.onConnectionStateChange = null;\n    this.onDataReceived = null;\n    this.onDebugLog = null;\n    this.connectionTimeout = null;\n    \n    // WebRTC configuration with STUN servers\n    this.config = {\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n        { urls: 'stun:stun2.l.google.com:19302' }\n      ],\n      iceCandidatePoolSize: 10\n    };\n  }\n\n  // Connect to signaling server\n  connectToSignalingServer() {\n    this.debugLog('üîó Connecting to signaling server...');\n    \n    // Use HTTP for signaling server for better WebSocket compatibility\n    // Even if main app is HTTPS, signaling can use HTTP in development\n    const currentHost = window.location.hostname;\n    const signalingUrl = `http://${currentHost}:3001`;\n    \n    this.debugLog(`üì° Signaling server URL: ${signalingUrl}`);\n    this.debugLog(`üåç Current page: ${window.location.href}`);\n    this.debugLog(`üí° Using HTTP signaling for better compatibility`);\n    \n    this.socket = io(signalingUrl, {\n      transports: ['websocket', 'polling'],\n      timeout: 20000,\n      forceNew: true,\n      upgrade: true,\n      rememberUpgrade: false\n    });\n\n    this.socket.on('connect', () => {\n      this.debugLog('‚úÖ Connected to signaling server');\n    });\n\n    this.socket.on('disconnect', (reason) => {\n      this.debugLog(`‚ùå Disconnected from signaling server: ${reason}`);\n    });\n\n    this.socket.on('connect_error', (error) => {\n      this.debugLog(`‚ùå Connection error: ${error.message}`);\n      this.debugLog(`üîß Trying to connect to: ${signalingUrl}`);\n      \n      // Provide helpful troubleshooting info\n      this.debugLog('üí° Signaling server uses HTTP for better WebSocket compatibility');\n    });\n\n    // Listen for WebRTC signaling events\n    this.setupSignalingListeners();\n  }\n\n  setupSignalingListeners() {\n    // Handle incoming offer\n    this.socket.on('webrtc-offer', async (data) => {\n      this.debugLog('üì• Received WebRTC offer');\n      this.debugLog(`üìã Offer details: ${JSON.stringify(data.offer).substring(0, 100)}...`);\n      try {\n        await this.handleOffer(data.offer);\n        this.debugLog('‚úÖ Processed offer and sent answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      }\n    });\n\n    // Handle incoming answer\n    this.socket.on('webrtc-answer', async (data) => {\n      this.debugLog('üì• Received WebRTC answer');\n      this.debugLog(`üìã Answer details: ${JSON.stringify(data.answer).substring(0, 100)}...`);\n      try {\n        await this.handleAnswer(data.answer);\n        this.debugLog('‚úÖ Processed answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      }\n    });\n\n    // Handle ICE candidates\n    this.socket.on('webrtc-ice-candidate', async (data) => {\n      this.debugLog('üßä Received ICE candidate');\n      this.debugLog(`üîç ICE candidate type: ${data.candidate?.type || 'unknown'}`);\n      try {\n        await this.handleIceCandidate(data.candidate);\n        this.debugLog('‚úÖ ICE candidate added successfully');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling ICE candidate: ${error.message}`);\n      }\n    });\n\n    // Handle call initiation (for host)\n    this.socket.on('start-call', async () => {\n      this.debugLog('üöÄ Starting call as host');\n      \n      try {\n        if (this.peerConnection && this.peerConnection.signalingState === 'stable') {\n          await this.createOffer();\n        } else {\n          this.debugLog('‚ùå Peer connection not ready, skipping offer creation');\n        }\n      } catch (error) {\n        this.debugLog(`‚ùå Error in start-call: ${error.message}`);\n      }\n    });\n\n    // Handle user events\n    this.socket.on('user-joined', (data) => {\n      this.debugLog(`üëã User joined room (${data.participantCount} total)`);\n    });\n\n    this.socket.on('user-left', (data) => {\n      this.debugLog(`üëã User left room (${data.participantCount} remaining)`);\n      if (data.participantCount === 0) {\n        this.cleanup();\n      }\n    });\n  }\n\n  // Join or create a room\n  async joinRoom(roomId) {\n    if (!this.socket) {\n      this.connectToSignalingServer();\n      await new Promise(resolve => {\n        this.socket.on('connect', resolve);\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      this.roomId = roomId;\n      \n      this.socket.emit('join-room', roomId, (response) => {\n        if (response.success) {\n          this.isHost = response.isHost;\n          this.debugLog(`‚úÖ Joined room as ${this.isHost ? 'HOST' : 'GUEST'}`);\n          this.debugLog(`üë• Participants: ${response.participantCount}/2`);\n          \n          // Initialize WebRTC\n          this.initializePeerConnection();\n          \n          resolve({\n            success: true,\n            isHost: this.isHost,\n            participantCount: response.participantCount\n          });\n        } else {\n          this.debugLog(`‚ùå Failed to join room: ${response.message}`);\n          reject(new Error(response.message));\n        }\n      });\n    });\n  }\n\n  initializePeerConnection() {\n    this.debugLog('üîÑ Initializing peer connection...');\n    \n    this.peerConnection = new RTCPeerConnection(this.config);\n\n    // Create data channel (host only)\n    if (this.isHost) {\n      this.dataChannel = this.peerConnection.createDataChannel('whiteboard', {\n        ordered: true\n      });\n      this.setupDataChannel();\n      this.debugLog('üì∫ Data channel created (host)');\n    }\n\n    // Handle incoming data channel (guest)\n    this.peerConnection.ondatachannel = (event) => {\n      this.debugLog('üì∫ Data channel received (guest)');\n      this.dataChannel = event.channel;\n      this.setupDataChannel();\n    };\n\n    // Handle ICE candidates\n    this.peerConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        this.debugLog('üßä Sending ICE candidate');\n        this.socket.emit('webrtc-ice-candidate', {\n          candidate: event.candidate\n        });\n      }\n    };\n\n    // Monitor connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      const state = this.peerConnection.connectionState;\n      this.debugLog(`üîÑ Connection state: ${state}`);\n      \n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(state);\n      }\n\n      if (state === 'connected') {\n        this.debugLog('üéâ WebRTC connection established!');\n        if (this.connectionTimeout) {\n          clearTimeout(this.connectionTimeout);\n        }\n      } else if (state === 'failed' || state === 'disconnected') {\n        this.debugLog('‚ùå Connection failed or disconnected');\n        this.cleanup();\n      }\n    };\n\n    // Monitor ICE connection state\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const iceState = this.peerConnection.iceConnectionState;\n      this.debugLog(`üßä ICE connection state: ${iceState}`);\n    };\n\n    // Monitor signaling state\n    this.peerConnection.onsignalingstatechange = () => {\n      const signalingState = this.peerConnection.signalingState;\n      this.debugLog(`üì° Signaling state: ${signalingState}`);\n    };\n\n    // Set connection timeout\n    this.connectionTimeout = setTimeout(() => {\n      if (this.peerConnection?.connectionState !== 'connected') {\n        this.debugLog('‚è∞ Connection timeout - cleaning up');\n        this.debugLog(`üîç Final states - Connection: ${this.peerConnection?.connectionState}, ICE: ${this.peerConnection?.iceConnectionState}, Signaling: ${this.peerConnection?.signalingState}`);\n        this.cleanup();\n      }\n    }, 30000); // 30 second timeout\n  }\n\n  setupDataChannel() {\n    this.dataChannel.onopen = () => {\n      this.debugLog('üì∫ Data channel opened');\n    };\n\n    this.dataChannel.onclose = () => {\n      this.debugLog('üì∫ Data channel closed');\n    };\n\n    this.dataChannel.onmessage = (event) => {\n      if (this.onDataReceived) {\n        const data = JSON.parse(event.data);\n        this.onDataReceived(data);\n      }\n    };\n\n    this.dataChannel.onerror = (error) => {\n      this.debugLog(`‚ùå Data channel error: ${error}`);\n    };\n  }\n\n  async createOffer() {\n    try {\n      this.debugLog('üì§ Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n      await this.peerConnection.setLocalDescription(offer);\n      this.socket.emit('webrtc-offer', { offer });\n      this.debugLog('üì§ Offer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error creating offer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async handleOffer(offer) {\n    try {\n      await this.peerConnection.setRemoteDescription(offer);\n      const answer = await this.peerConnection.createAnswer();\n      await this.peerConnection.setLocalDescription(answer);\n      \n      this.socket.emit('webrtc-answer', { answer });\n      this.debugLog('üì§ Answer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async handleAnswer(answer) {\n    try {\n      await this.peerConnection.setRemoteDescription(answer);\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async handleIceCandidate(candidate) {\n    try {\n      await this.peerConnection.addIceCandidate(candidate);\n    } catch (error) {\n      this.debugLog(`‚ùå Error adding ICE candidate: ${error.message}`);\n    }\n  }\n\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      this.dataChannel.send(JSON.stringify(data));\n      return true;\n    }\n    return false;\n  }\n\n  getConnectionState() {\n    return this.peerConnection?.connectionState || 'new';\n  }\n\n  cleanup() {\n    this.debugLog('üßπ Cleaning up WebRTC connection...');\n    \n    if (this.connectionTimeout) {\n      clearTimeout(this.connectionTimeout);\n    }\n\n    if (this.dataChannel) {\n      this.dataChannel.close();\n      this.dataChannel = null;\n    }\n\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n\n    this.roomId = null;\n    this.isHost = false;\n  }\n\n  debugLog(message) {\n    console.log(`[WebRTC] ${message}`);\n    if (this.onDebugLog) {\n      this.onDebugLog(message);\n    }\n  }\n}\n\nexport default WebRTCManager; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}