{"ast":null,"code":"import { io } from 'socket.io-client';\nclass WebRTCManager {\n  constructor() {\n    this.peerConnection = null;\n    this.dataChannel = null;\n    this.socket = null;\n    this.roomId = null;\n    this.isHost = false;\n    this.onConnectionStateChange = null;\n    this.onDataReceived = null;\n    this.onDebugLog = null;\n    this.connectionTimeout = null;\n\n    // WebRTC configuration with STUN servers\n    this.config = {\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }, {\n        urls: 'stun:stun2.l.google.com:19302'\n      }],\n      iceCandidatePoolSize: 10\n    };\n  }\n\n  // Connect to signaling server\n  connectToSignalingServer() {\n    this.debugLog('üîó Connecting to signaling server...');\n\n    // Use HTTP for signaling server for better WebSocket compatibility\n    // Even if main app is HTTPS, signaling can use HTTP in development\n    const currentHost = window.location.hostname;\n    const signalingUrl = `http://${currentHost}:3001`;\n    this.debugLog(`üì° Signaling server URL: ${signalingUrl}`);\n    this.debugLog(`üåç Current page: ${window.location.href}`);\n    this.debugLog(`üí° Using HTTP signaling for better compatibility`);\n    this.socket = io(signalingUrl, {\n      transports: ['websocket', 'polling'],\n      timeout: 20000,\n      forceNew: true,\n      upgrade: true,\n      rememberUpgrade: false\n    });\n    this.socket.on('connect', () => {\n      this.debugLog('‚úÖ Connected to signaling server');\n    });\n    this.socket.on('disconnect', reason => {\n      this.debugLog(`‚ùå Disconnected from signaling server: ${reason}`);\n    });\n    this.socket.on('connect_error', error => {\n      this.debugLog(`‚ùå Connection error: ${error.message}`);\n      this.debugLog(`üîß Trying to connect to: ${signalingUrl}`);\n\n      // Provide helpful troubleshooting info\n      this.debugLog('üí° Signaling server uses HTTP for better WebSocket compatibility');\n    });\n\n    // Listen for WebRTC signaling events\n    this.setupSignalingListeners();\n  }\n  setupSignalingListeners() {\n    // Handle incoming offer\n    this.socket.on('webrtc-offer', async data => {\n      this.debugLog('üì• Received WebRTC offer');\n      try {\n        await this.handleOffer(data.offer);\n        this.debugLog('‚úÖ Processed offer and sent answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      }\n    });\n\n    // Handle incoming answer\n    this.socket.on('webrtc-answer', async data => {\n      this.debugLog('üì• Received WebRTC answer');\n      try {\n        await this.handleAnswer(data.answer);\n        this.debugLog('‚úÖ Processed answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      }\n    });\n\n    // Handle ICE candidates\n    this.socket.on('webrtc-ice-candidate', async data => {\n      this.debugLog('üßä Received ICE candidate');\n      try {\n        await this.handleIceCandidate(data.candidate);\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling ICE candidate: ${error.message}`);\n      }\n    });\n\n    // Handle call initiation (for host)\n    this.socket.on('start-call', async () => {\n      this.debugLog('üöÄ Starting call as host');\n      try {\n        if (this.peerConnection && this.peerConnection.signalingState === 'stable') {\n          await this.createOffer();\n        } else {\n          this.debugLog('‚ùå Peer connection not ready, skipping offer creation');\n        }\n      } catch (error) {\n        this.debugLog(`‚ùå Error in start-call: ${error.message}`);\n      }\n    });\n\n    // Handle user events\n    this.socket.on('user-joined', data => {\n      this.debugLog(`üëã User joined room (${data.participantCount} total)`);\n    });\n    this.socket.on('user-left', data => {\n      this.debugLog(`üëã User left room (${data.participantCount} remaining)`);\n      if (data.participantCount === 0) {\n        this.cleanup();\n      }\n    });\n  }\n\n  // Join or create a room\n  async joinRoom(roomId) {\n    if (!this.socket) {\n      this.connectToSignalingServer();\n      await new Promise(resolve => {\n        this.socket.on('connect', resolve);\n      });\n    }\n    return new Promise((resolve, reject) => {\n      this.roomId = roomId;\n      this.socket.emit('join-room', roomId, response => {\n        if (response.success) {\n          this.isHost = response.isHost;\n          this.debugLog(`‚úÖ Joined room as ${this.isHost ? 'HOST' : 'GUEST'}`);\n          this.debugLog(`üë• Participants: ${response.participantCount}/2`);\n\n          // Initialize WebRTC\n          this.initializePeerConnection();\n          resolve({\n            success: true,\n            isHost: this.isHost,\n            participantCount: response.participantCount\n          });\n        } else {\n          this.debugLog(`‚ùå Failed to join room: ${response.message}`);\n          reject(new Error(response.message));\n        }\n      });\n    });\n  }\n  initializePeerConnection() {\n    this.debugLog('üîÑ Initializing peer connection...');\n    this.peerConnection = new RTCPeerConnection(this.config);\n\n    // Create data channel (host only)\n    if (this.isHost) {\n      this.dataChannel = this.peerConnection.createDataChannel('whiteboard', {\n        ordered: true\n      });\n      this.setupDataChannel();\n      this.debugLog('üì∫ Data channel created (host)');\n    }\n\n    // Handle incoming data channel (guest)\n    this.peerConnection.ondatachannel = event => {\n      this.debugLog('üì∫ Data channel received (guest)');\n      this.dataChannel = event.channel;\n      this.setupDataChannel();\n    };\n\n    // Handle ICE candidates\n    this.peerConnection.onicecandidate = event => {\n      if (event.candidate) {\n        this.debugLog('üßä Sending ICE candidate');\n        this.socket.emit('webrtc-ice-candidate', {\n          candidate: event.candidate\n        });\n      }\n    };\n\n    // Monitor connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      const state = this.peerConnection.connectionState;\n      this.debugLog(`üîÑ Connection state: ${state}`);\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(state);\n      }\n      if (state === 'connected') {\n        this.debugLog('üéâ WebRTC connection established!');\n        if (this.connectionTimeout) {\n          clearTimeout(this.connectionTimeout);\n        }\n      } else if (state === 'failed' || state === 'disconnected') {\n        this.debugLog('‚ùå Connection failed or disconnected');\n        this.cleanup();\n      }\n    };\n\n    // Monitor ICE connection state\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const iceState = this.peerConnection.iceConnectionState;\n      this.debugLog(`üßä ICE connection state: ${iceState}`);\n    };\n\n    // Monitor signaling state\n    this.peerConnection.onsignalingstatechange = () => {\n      const signalingState = this.peerConnection.signalingState;\n      this.debugLog(`üì° Signaling state: ${signalingState}`);\n    };\n\n    // Set connection timeout\n    this.connectionTimeout = setTimeout(() => {\n      var _this$peerConnection;\n      if (((_this$peerConnection = this.peerConnection) === null || _this$peerConnection === void 0 ? void 0 : _this$peerConnection.connectionState) !== 'connected') {\n        var _this$peerConnection2, _this$peerConnection3, _this$peerConnection4;\n        this.debugLog('‚è∞ Connection timeout - cleaning up');\n        this.debugLog(`üîç Final states - Connection: ${(_this$peerConnection2 = this.peerConnection) === null || _this$peerConnection2 === void 0 ? void 0 : _this$peerConnection2.connectionState}, ICE: ${(_this$peerConnection3 = this.peerConnection) === null || _this$peerConnection3 === void 0 ? void 0 : _this$peerConnection3.iceConnectionState}, Signaling: ${(_this$peerConnection4 = this.peerConnection) === null || _this$peerConnection4 === void 0 ? void 0 : _this$peerConnection4.signalingState}`);\n        this.cleanup();\n      }\n    }, 30000); // 30 second timeout\n  }\n  setupDataChannel() {\n    this.dataChannel.onopen = () => {\n      this.debugLog('üì∫ Data channel opened');\n    };\n    this.dataChannel.onclose = () => {\n      this.debugLog('üì∫ Data channel closed');\n    };\n    this.dataChannel.onmessage = event => {\n      if (this.onDataReceived) {\n        const data = JSON.parse(event.data);\n        this.onDataReceived(data);\n      }\n    };\n    this.dataChannel.onerror = error => {\n      this.debugLog(`‚ùå Data channel error: ${error}`);\n    };\n  }\n  async createOffer() {\n    try {\n      this.debugLog('üì§ Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n      await this.peerConnection.setLocalDescription(offer);\n      this.socket.emit('webrtc-offer', {\n        offer\n      });\n      this.debugLog('üì§ Offer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error creating offer: ${error.message}`);\n      throw error;\n    }\n  }\n  async handleOffer(offer) {\n    try {\n      await this.peerConnection.setRemoteDescription(offer);\n      const answer = await this.peerConnection.createAnswer();\n      await this.peerConnection.setLocalDescription(answer);\n      this.socket.emit('webrtc-answer', {\n        answer\n      });\n      this.debugLog('üì§ Answer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      throw error;\n    }\n  }\n  async handleAnswer(answer) {\n    try {\n      await this.peerConnection.setRemoteDescription(answer);\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      throw error;\n    }\n  }\n  async handleIceCandidate(candidate) {\n    try {\n      await this.peerConnection.addIceCandidate(candidate);\n    } catch (error) {\n      this.debugLog(`‚ùå Error adding ICE candidate: ${error.message}`);\n    }\n  }\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      this.dataChannel.send(JSON.stringify(data));\n      return true;\n    }\n    return false;\n  }\n  getConnectionState() {\n    var _this$peerConnection5;\n    return ((_this$peerConnection5 = this.peerConnection) === null || _this$peerConnection5 === void 0 ? void 0 : _this$peerConnection5.connectionState) || 'new';\n  }\n  cleanup() {\n    this.debugLog('üßπ Cleaning up WebRTC connection...');\n    if (this.connectionTimeout) {\n      clearTimeout(this.connectionTimeout);\n    }\n    if (this.dataChannel) {\n      this.dataChannel.close();\n      this.dataChannel = null;\n    }\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    this.roomId = null;\n    this.isHost = false;\n  }\n  debugLog(message) {\n    console.log(`[WebRTC] ${message}`);\n    if (this.onDebugLog) {\n      this.onDebugLog(message);\n    }\n  }\n}\nexport default WebRTCManager;","map":{"version":3,"names":["io","WebRTCManager","constructor","peerConnection","dataChannel","socket","roomId","isHost","onConnectionStateChange","onDataReceived","onDebugLog","connectionTimeout","config","iceServers","urls","iceCandidatePoolSize","connectToSignalingServer","debugLog","currentHost","window","location","hostname","signalingUrl","href","transports","timeout","forceNew","upgrade","rememberUpgrade","on","reason","error","message","setupSignalingListeners","data","handleOffer","offer","handleAnswer","answer","handleIceCandidate","candidate","signalingState","createOffer","participantCount","cleanup","joinRoom","Promise","resolve","reject","emit","response","success","initializePeerConnection","Error","RTCPeerConnection","createDataChannel","ordered","setupDataChannel","ondatachannel","event","channel","onicecandidate","onconnectionstatechange","state","connectionState","clearTimeout","oniceconnectionstatechange","iceState","iceConnectionState","onsignalingstatechange","setTimeout","_this$peerConnection","_this$peerConnection2","_this$peerConnection3","_this$peerConnection4","onopen","onclose","onmessage","JSON","parse","onerror","setLocalDescription","setRemoteDescription","createAnswer","addIceCandidate","sendData","readyState","send","stringify","getConnectionState","_this$peerConnection5","close","disconnect","console","log"],"sources":["C:/Users/eniac/Desktop/wrtc/src/services/WebRTCManager.js"],"sourcesContent":["import { io } from 'socket.io-client';\n\nclass WebRTCManager {\n  constructor() {\n    this.peerConnection = null;\n    this.dataChannel = null;\n    this.socket = null;\n    this.roomId = null;\n    this.isHost = false;\n    this.onConnectionStateChange = null;\n    this.onDataReceived = null;\n    this.onDebugLog = null;\n    this.connectionTimeout = null;\n    \n    // WebRTC configuration with STUN servers\n    this.config = {\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n        { urls: 'stun:stun2.l.google.com:19302' }\n      ],\n      iceCandidatePoolSize: 10\n    };\n  }\n\n  // Connect to signaling server\n  connectToSignalingServer() {\n    this.debugLog('üîó Connecting to signaling server...');\n    \n    // Use HTTP for signaling server for better WebSocket compatibility\n    // Even if main app is HTTPS, signaling can use HTTP in development\n    const currentHost = window.location.hostname;\n    const signalingUrl = `http://${currentHost}:3001`;\n    \n    this.debugLog(`üì° Signaling server URL: ${signalingUrl}`);\n    this.debugLog(`üåç Current page: ${window.location.href}`);\n    this.debugLog(`üí° Using HTTP signaling for better compatibility`);\n    \n    this.socket = io(signalingUrl, {\n      transports: ['websocket', 'polling'],\n      timeout: 20000,\n      forceNew: true,\n      upgrade: true,\n      rememberUpgrade: false\n    });\n\n    this.socket.on('connect', () => {\n      this.debugLog('‚úÖ Connected to signaling server');\n    });\n\n    this.socket.on('disconnect', (reason) => {\n      this.debugLog(`‚ùå Disconnected from signaling server: ${reason}`);\n    });\n\n    this.socket.on('connect_error', (error) => {\n      this.debugLog(`‚ùå Connection error: ${error.message}`);\n      this.debugLog(`üîß Trying to connect to: ${signalingUrl}`);\n      \n      // Provide helpful troubleshooting info\n      this.debugLog('üí° Signaling server uses HTTP for better WebSocket compatibility');\n    });\n\n    // Listen for WebRTC signaling events\n    this.setupSignalingListeners();\n  }\n\n  setupSignalingListeners() {\n    // Handle incoming offer\n    this.socket.on('webrtc-offer', async (data) => {\n      this.debugLog('üì• Received WebRTC offer');\n      try {\n        await this.handleOffer(data.offer);\n        this.debugLog('‚úÖ Processed offer and sent answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      }\n    });\n\n    // Handle incoming answer\n    this.socket.on('webrtc-answer', async (data) => {\n      this.debugLog('üì• Received WebRTC answer');\n      try {\n        await this.handleAnswer(data.answer);\n        this.debugLog('‚úÖ Processed answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      }\n    });\n\n    // Handle ICE candidates\n    this.socket.on('webrtc-ice-candidate', async (data) => {\n      this.debugLog('üßä Received ICE candidate');\n      try {\n        await this.handleIceCandidate(data.candidate);\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling ICE candidate: ${error.message}`);\n      }\n    });\n\n    // Handle call initiation (for host)\n    this.socket.on('start-call', async () => {\n      this.debugLog('üöÄ Starting call as host');\n      \n      try {\n        if (this.peerConnection && this.peerConnection.signalingState === 'stable') {\n          await this.createOffer();\n        } else {\n          this.debugLog('‚ùå Peer connection not ready, skipping offer creation');\n        }\n      } catch (error) {\n        this.debugLog(`‚ùå Error in start-call: ${error.message}`);\n      }\n    });\n\n    // Handle user events\n    this.socket.on('user-joined', (data) => {\n      this.debugLog(`üëã User joined room (${data.participantCount} total)`);\n    });\n\n    this.socket.on('user-left', (data) => {\n      this.debugLog(`üëã User left room (${data.participantCount} remaining)`);\n      if (data.participantCount === 0) {\n        this.cleanup();\n      }\n    });\n  }\n\n  // Join or create a room\n  async joinRoom(roomId) {\n    if (!this.socket) {\n      this.connectToSignalingServer();\n      await new Promise(resolve => {\n        this.socket.on('connect', resolve);\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      this.roomId = roomId;\n      \n      this.socket.emit('join-room', roomId, (response) => {\n        if (response.success) {\n          this.isHost = response.isHost;\n          this.debugLog(`‚úÖ Joined room as ${this.isHost ? 'HOST' : 'GUEST'}`);\n          this.debugLog(`üë• Participants: ${response.participantCount}/2`);\n          \n          // Initialize WebRTC\n          this.initializePeerConnection();\n          \n          resolve({\n            success: true,\n            isHost: this.isHost,\n            participantCount: response.participantCount\n          });\n        } else {\n          this.debugLog(`‚ùå Failed to join room: ${response.message}`);\n          reject(new Error(response.message));\n        }\n      });\n    });\n  }\n\n  initializePeerConnection() {\n    this.debugLog('üîÑ Initializing peer connection...');\n    \n    this.peerConnection = new RTCPeerConnection(this.config);\n\n    // Create data channel (host only)\n    if (this.isHost) {\n      this.dataChannel = this.peerConnection.createDataChannel('whiteboard', {\n        ordered: true\n      });\n      this.setupDataChannel();\n      this.debugLog('üì∫ Data channel created (host)');\n    }\n\n    // Handle incoming data channel (guest)\n    this.peerConnection.ondatachannel = (event) => {\n      this.debugLog('üì∫ Data channel received (guest)');\n      this.dataChannel = event.channel;\n      this.setupDataChannel();\n    };\n\n    // Handle ICE candidates\n    this.peerConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        this.debugLog('üßä Sending ICE candidate');\n        this.socket.emit('webrtc-ice-candidate', {\n          candidate: event.candidate\n        });\n      }\n    };\n\n    // Monitor connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      const state = this.peerConnection.connectionState;\n      this.debugLog(`üîÑ Connection state: ${state}`);\n      \n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(state);\n      }\n\n      if (state === 'connected') {\n        this.debugLog('üéâ WebRTC connection established!');\n        if (this.connectionTimeout) {\n          clearTimeout(this.connectionTimeout);\n        }\n      } else if (state === 'failed' || state === 'disconnected') {\n        this.debugLog('‚ùå Connection failed or disconnected');\n        this.cleanup();\n      }\n    };\n\n    // Monitor ICE connection state\n    this.peerConnection.oniceconnectionstatechange = () => {\n      const iceState = this.peerConnection.iceConnectionState;\n      this.debugLog(`üßä ICE connection state: ${iceState}`);\n    };\n\n    // Monitor signaling state\n    this.peerConnection.onsignalingstatechange = () => {\n      const signalingState = this.peerConnection.signalingState;\n      this.debugLog(`üì° Signaling state: ${signalingState}`);\n    };\n\n    // Set connection timeout\n    this.connectionTimeout = setTimeout(() => {\n      if (this.peerConnection?.connectionState !== 'connected') {\n        this.debugLog('‚è∞ Connection timeout - cleaning up');\n        this.debugLog(`üîç Final states - Connection: ${this.peerConnection?.connectionState}, ICE: ${this.peerConnection?.iceConnectionState}, Signaling: ${this.peerConnection?.signalingState}`);\n        this.cleanup();\n      }\n    }, 30000); // 30 second timeout\n  }\n\n  setupDataChannel() {\n    this.dataChannel.onopen = () => {\n      this.debugLog('üì∫ Data channel opened');\n    };\n\n    this.dataChannel.onclose = () => {\n      this.debugLog('üì∫ Data channel closed');\n    };\n\n    this.dataChannel.onmessage = (event) => {\n      if (this.onDataReceived) {\n        const data = JSON.parse(event.data);\n        this.onDataReceived(data);\n      }\n    };\n\n    this.dataChannel.onerror = (error) => {\n      this.debugLog(`‚ùå Data channel error: ${error}`);\n    };\n  }\n\n  async createOffer() {\n    try {\n      this.debugLog('üì§ Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n      await this.peerConnection.setLocalDescription(offer);\n      this.socket.emit('webrtc-offer', { offer });\n      this.debugLog('üì§ Offer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error creating offer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async handleOffer(offer) {\n    try {\n      await this.peerConnection.setRemoteDescription(offer);\n      const answer = await this.peerConnection.createAnswer();\n      await this.peerConnection.setLocalDescription(answer);\n      \n      this.socket.emit('webrtc-answer', { answer });\n      this.debugLog('üì§ Answer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async handleAnswer(answer) {\n    try {\n      await this.peerConnection.setRemoteDescription(answer);\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async handleIceCandidate(candidate) {\n    try {\n      await this.peerConnection.addIceCandidate(candidate);\n    } catch (error) {\n      this.debugLog(`‚ùå Error adding ICE candidate: ${error.message}`);\n    }\n  }\n\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      this.dataChannel.send(JSON.stringify(data));\n      return true;\n    }\n    return false;\n  }\n\n  getConnectionState() {\n    return this.peerConnection?.connectionState || 'new';\n  }\n\n  cleanup() {\n    this.debugLog('üßπ Cleaning up WebRTC connection...');\n    \n    if (this.connectionTimeout) {\n      clearTimeout(this.connectionTimeout);\n    }\n\n    if (this.dataChannel) {\n      this.dataChannel.close();\n      this.dataChannel = null;\n    }\n\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n\n    this.roomId = null;\n    this.isHost = false;\n  }\n\n  debugLog(message) {\n    console.log(`[WebRTC] ${message}`);\n    if (this.onDebugLog) {\n      this.onDebugLog(message);\n    }\n  }\n}\n\nexport default WebRTCManager; "],"mappings":"AAAA,SAASA,EAAE,QAAQ,kBAAkB;AAErC,MAAMC,aAAa,CAAC;EAClBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,MAAM,GAAG,KAAK;IACnB,IAAI,CAACC,uBAAuB,GAAG,IAAI;IACnC,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB,IAAI,CAACC,iBAAiB,GAAG,IAAI;;IAE7B;IACA,IAAI,CAACC,MAAM,GAAG;MACZC,UAAU,EAAE,CACV;QAAEC,IAAI,EAAE;MAA+B,CAAC,EACxC;QAAEA,IAAI,EAAE;MAAgC,CAAC,EACzC;QAAEA,IAAI,EAAE;MAAgC,CAAC,CAC1C;MACDC,oBAAoB,EAAE;IACxB,CAAC;EACH;;EAEA;EACAC,wBAAwBA,CAAA,EAAG;IACzB,IAAI,CAACC,QAAQ,CAAC,sCAAsC,CAAC;;IAErD;IACA;IACA,MAAMC,WAAW,GAAGC,MAAM,CAACC,QAAQ,CAACC,QAAQ;IAC5C,MAAMC,YAAY,GAAG,UAAUJ,WAAW,OAAO;IAEjD,IAAI,CAACD,QAAQ,CAAC,4BAA4BK,YAAY,EAAE,CAAC;IACzD,IAAI,CAACL,QAAQ,CAAC,oBAAoBE,MAAM,CAACC,QAAQ,CAACG,IAAI,EAAE,CAAC;IACzD,IAAI,CAACN,QAAQ,CAAC,kDAAkD,CAAC;IAEjE,IAAI,CAACZ,MAAM,GAAGL,EAAE,CAACsB,YAAY,EAAE;MAC7BE,UAAU,EAAE,CAAC,WAAW,EAAE,SAAS,CAAC;MACpCC,OAAO,EAAE,KAAK;MACdC,QAAQ,EAAE,IAAI;MACdC,OAAO,EAAE,IAAI;MACbC,eAAe,EAAE;IACnB,CAAC,CAAC;IAEF,IAAI,CAACvB,MAAM,CAACwB,EAAE,CAAC,SAAS,EAAE,MAAM;MAC9B,IAAI,CAACZ,QAAQ,CAAC,iCAAiC,CAAC;IAClD,CAAC,CAAC;IAEF,IAAI,CAACZ,MAAM,CAACwB,EAAE,CAAC,YAAY,EAAGC,MAAM,IAAK;MACvC,IAAI,CAACb,QAAQ,CAAC,yCAAyCa,MAAM,EAAE,CAAC;IAClE,CAAC,CAAC;IAEF,IAAI,CAACzB,MAAM,CAACwB,EAAE,CAAC,eAAe,EAAGE,KAAK,IAAK;MACzC,IAAI,CAACd,QAAQ,CAAC,uBAAuBc,KAAK,CAACC,OAAO,EAAE,CAAC;MACrD,IAAI,CAACf,QAAQ,CAAC,4BAA4BK,YAAY,EAAE,CAAC;;MAEzD;MACA,IAAI,CAACL,QAAQ,CAAC,kEAAkE,CAAC;IACnF,CAAC,CAAC;;IAEF;IACA,IAAI,CAACgB,uBAAuB,CAAC,CAAC;EAChC;EAEAA,uBAAuBA,CAAA,EAAG;IACxB;IACA,IAAI,CAAC5B,MAAM,CAACwB,EAAE,CAAC,cAAc,EAAE,MAAOK,IAAI,IAAK;MAC7C,IAAI,CAACjB,QAAQ,CAAC,0BAA0B,CAAC;MACzC,IAAI;QACF,MAAM,IAAI,CAACkB,WAAW,CAACD,IAAI,CAACE,KAAK,CAAC;QAClC,IAAI,CAACnB,QAAQ,CAAC,mCAAmC,CAAC;MACpD,CAAC,CAAC,OAAOc,KAAK,EAAE;QACd,IAAI,CAACd,QAAQ,CAAC,2BAA2Bc,KAAK,CAACC,OAAO,EAAE,CAAC;MAC3D;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,CAAC3B,MAAM,CAACwB,EAAE,CAAC,eAAe,EAAE,MAAOK,IAAI,IAAK;MAC9C,IAAI,CAACjB,QAAQ,CAAC,2BAA2B,CAAC;MAC1C,IAAI;QACF,MAAM,IAAI,CAACoB,YAAY,CAACH,IAAI,CAACI,MAAM,CAAC;QACpC,IAAI,CAACrB,QAAQ,CAAC,oBAAoB,CAAC;MACrC,CAAC,CAAC,OAAOc,KAAK,EAAE;QACd,IAAI,CAACd,QAAQ,CAAC,4BAA4Bc,KAAK,CAACC,OAAO,EAAE,CAAC;MAC5D;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,CAAC3B,MAAM,CAACwB,EAAE,CAAC,sBAAsB,EAAE,MAAOK,IAAI,IAAK;MACrD,IAAI,CAACjB,QAAQ,CAAC,2BAA2B,CAAC;MAC1C,IAAI;QACF,MAAM,IAAI,CAACsB,kBAAkB,CAACL,IAAI,CAACM,SAAS,CAAC;MAC/C,CAAC,CAAC,OAAOT,KAAK,EAAE;QACd,IAAI,CAACd,QAAQ,CAAC,mCAAmCc,KAAK,CAACC,OAAO,EAAE,CAAC;MACnE;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,CAAC3B,MAAM,CAACwB,EAAE,CAAC,YAAY,EAAE,YAAY;MACvC,IAAI,CAACZ,QAAQ,CAAC,0BAA0B,CAAC;MAEzC,IAAI;QACF,IAAI,IAAI,CAACd,cAAc,IAAI,IAAI,CAACA,cAAc,CAACsC,cAAc,KAAK,QAAQ,EAAE;UAC1E,MAAM,IAAI,CAACC,WAAW,CAAC,CAAC;QAC1B,CAAC,MAAM;UACL,IAAI,CAACzB,QAAQ,CAAC,sDAAsD,CAAC;QACvE;MACF,CAAC,CAAC,OAAOc,KAAK,EAAE;QACd,IAAI,CAACd,QAAQ,CAAC,0BAA0Bc,KAAK,CAACC,OAAO,EAAE,CAAC;MAC1D;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,CAAC3B,MAAM,CAACwB,EAAE,CAAC,aAAa,EAAGK,IAAI,IAAK;MACtC,IAAI,CAACjB,QAAQ,CAAC,wBAAwBiB,IAAI,CAACS,gBAAgB,SAAS,CAAC;IACvE,CAAC,CAAC;IAEF,IAAI,CAACtC,MAAM,CAACwB,EAAE,CAAC,WAAW,EAAGK,IAAI,IAAK;MACpC,IAAI,CAACjB,QAAQ,CAAC,sBAAsBiB,IAAI,CAACS,gBAAgB,aAAa,CAAC;MACvE,IAAIT,IAAI,CAACS,gBAAgB,KAAK,CAAC,EAAE;QAC/B,IAAI,CAACC,OAAO,CAAC,CAAC;MAChB;IACF,CAAC,CAAC;EACJ;;EAEA;EACA,MAAMC,QAAQA,CAACvC,MAAM,EAAE;IACrB,IAAI,CAAC,IAAI,CAACD,MAAM,EAAE;MAChB,IAAI,CAACW,wBAAwB,CAAC,CAAC;MAC/B,MAAM,IAAI8B,OAAO,CAACC,OAAO,IAAI;QAC3B,IAAI,CAAC1C,MAAM,CAACwB,EAAE,CAAC,SAAS,EAAEkB,OAAO,CAAC;MACpC,CAAC,CAAC;IACJ;IAEA,OAAO,IAAID,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI,CAAC1C,MAAM,GAAGA,MAAM;MAEpB,IAAI,CAACD,MAAM,CAAC4C,IAAI,CAAC,WAAW,EAAE3C,MAAM,EAAG4C,QAAQ,IAAK;QAClD,IAAIA,QAAQ,CAACC,OAAO,EAAE;UACpB,IAAI,CAAC5C,MAAM,GAAG2C,QAAQ,CAAC3C,MAAM;UAC7B,IAAI,CAACU,QAAQ,CAAC,oBAAoB,IAAI,CAACV,MAAM,GAAG,MAAM,GAAG,OAAO,EAAE,CAAC;UACnE,IAAI,CAACU,QAAQ,CAAC,oBAAoBiC,QAAQ,CAACP,gBAAgB,IAAI,CAAC;;UAEhE;UACA,IAAI,CAACS,wBAAwB,CAAC,CAAC;UAE/BL,OAAO,CAAC;YACNI,OAAO,EAAE,IAAI;YACb5C,MAAM,EAAE,IAAI,CAACA,MAAM;YACnBoC,gBAAgB,EAAEO,QAAQ,CAACP;UAC7B,CAAC,CAAC;QACJ,CAAC,MAAM;UACL,IAAI,CAAC1B,QAAQ,CAAC,0BAA0BiC,QAAQ,CAAClB,OAAO,EAAE,CAAC;UAC3DgB,MAAM,CAAC,IAAIK,KAAK,CAACH,QAAQ,CAAClB,OAAO,CAAC,CAAC;QACrC;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEAoB,wBAAwBA,CAAA,EAAG;IACzB,IAAI,CAACnC,QAAQ,CAAC,oCAAoC,CAAC;IAEnD,IAAI,CAACd,cAAc,GAAG,IAAImD,iBAAiB,CAAC,IAAI,CAAC1C,MAAM,CAAC;;IAExD;IACA,IAAI,IAAI,CAACL,MAAM,EAAE;MACf,IAAI,CAACH,WAAW,GAAG,IAAI,CAACD,cAAc,CAACoD,iBAAiB,CAAC,YAAY,EAAE;QACrEC,OAAO,EAAE;MACX,CAAC,CAAC;MACF,IAAI,CAACC,gBAAgB,CAAC,CAAC;MACvB,IAAI,CAACxC,QAAQ,CAAC,gCAAgC,CAAC;IACjD;;IAEA;IACA,IAAI,CAACd,cAAc,CAACuD,aAAa,GAAIC,KAAK,IAAK;MAC7C,IAAI,CAAC1C,QAAQ,CAAC,kCAAkC,CAAC;MACjD,IAAI,CAACb,WAAW,GAAGuD,KAAK,CAACC,OAAO;MAChC,IAAI,CAACH,gBAAgB,CAAC,CAAC;IACzB,CAAC;;IAED;IACA,IAAI,CAACtD,cAAc,CAAC0D,cAAc,GAAIF,KAAK,IAAK;MAC9C,IAAIA,KAAK,CAACnB,SAAS,EAAE;QACnB,IAAI,CAACvB,QAAQ,CAAC,0BAA0B,CAAC;QACzC,IAAI,CAACZ,MAAM,CAAC4C,IAAI,CAAC,sBAAsB,EAAE;UACvCT,SAAS,EAAEmB,KAAK,CAACnB;QACnB,CAAC,CAAC;MACJ;IACF,CAAC;;IAED;IACA,IAAI,CAACrC,cAAc,CAAC2D,uBAAuB,GAAG,MAAM;MAClD,MAAMC,KAAK,GAAG,IAAI,CAAC5D,cAAc,CAAC6D,eAAe;MACjD,IAAI,CAAC/C,QAAQ,CAAC,wBAAwB8C,KAAK,EAAE,CAAC;MAE9C,IAAI,IAAI,CAACvD,uBAAuB,EAAE;QAChC,IAAI,CAACA,uBAAuB,CAACuD,KAAK,CAAC;MACrC;MAEA,IAAIA,KAAK,KAAK,WAAW,EAAE;QACzB,IAAI,CAAC9C,QAAQ,CAAC,mCAAmC,CAAC;QAClD,IAAI,IAAI,CAACN,iBAAiB,EAAE;UAC1BsD,YAAY,CAAC,IAAI,CAACtD,iBAAiB,CAAC;QACtC;MACF,CAAC,MAAM,IAAIoD,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,cAAc,EAAE;QACzD,IAAI,CAAC9C,QAAQ,CAAC,qCAAqC,CAAC;QACpD,IAAI,CAAC2B,OAAO,CAAC,CAAC;MAChB;IACF,CAAC;;IAED;IACA,IAAI,CAACzC,cAAc,CAAC+D,0BAA0B,GAAG,MAAM;MACrD,MAAMC,QAAQ,GAAG,IAAI,CAAChE,cAAc,CAACiE,kBAAkB;MACvD,IAAI,CAACnD,QAAQ,CAAC,4BAA4BkD,QAAQ,EAAE,CAAC;IACvD,CAAC;;IAED;IACA,IAAI,CAAChE,cAAc,CAACkE,sBAAsB,GAAG,MAAM;MACjD,MAAM5B,cAAc,GAAG,IAAI,CAACtC,cAAc,CAACsC,cAAc;MACzD,IAAI,CAACxB,QAAQ,CAAC,uBAAuBwB,cAAc,EAAE,CAAC;IACxD,CAAC;;IAED;IACA,IAAI,CAAC9B,iBAAiB,GAAG2D,UAAU,CAAC,MAAM;MAAA,IAAAC,oBAAA;MACxC,IAAI,EAAAA,oBAAA,OAAI,CAACpE,cAAc,cAAAoE,oBAAA,uBAAnBA,oBAAA,CAAqBP,eAAe,MAAK,WAAW,EAAE;QAAA,IAAAQ,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA;QACxD,IAAI,CAACzD,QAAQ,CAAC,oCAAoC,CAAC;QACnD,IAAI,CAACA,QAAQ,CAAC,kCAAAuD,qBAAA,GAAiC,IAAI,CAACrE,cAAc,cAAAqE,qBAAA,uBAAnBA,qBAAA,CAAqBR,eAAe,WAAAS,qBAAA,GAAU,IAAI,CAACtE,cAAc,cAAAsE,qBAAA,uBAAnBA,qBAAA,CAAqBL,kBAAkB,iBAAAM,qBAAA,GAAgB,IAAI,CAACvE,cAAc,cAAAuE,qBAAA,uBAAnBA,qBAAA,CAAqBjC,cAAc,EAAE,CAAC;QAC1L,IAAI,CAACG,OAAO,CAAC,CAAC;MAChB;IACF,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;EACb;EAEAa,gBAAgBA,CAAA,EAAG;IACjB,IAAI,CAACrD,WAAW,CAACuE,MAAM,GAAG,MAAM;MAC9B,IAAI,CAAC1D,QAAQ,CAAC,wBAAwB,CAAC;IACzC,CAAC;IAED,IAAI,CAACb,WAAW,CAACwE,OAAO,GAAG,MAAM;MAC/B,IAAI,CAAC3D,QAAQ,CAAC,wBAAwB,CAAC;IACzC,CAAC;IAED,IAAI,CAACb,WAAW,CAACyE,SAAS,GAAIlB,KAAK,IAAK;MACtC,IAAI,IAAI,CAAClD,cAAc,EAAE;QACvB,MAAMyB,IAAI,GAAG4C,IAAI,CAACC,KAAK,CAACpB,KAAK,CAACzB,IAAI,CAAC;QACnC,IAAI,CAACzB,cAAc,CAACyB,IAAI,CAAC;MAC3B;IACF,CAAC;IAED,IAAI,CAAC9B,WAAW,CAAC4E,OAAO,GAAIjD,KAAK,IAAK;MACpC,IAAI,CAACd,QAAQ,CAAC,yBAAyBc,KAAK,EAAE,CAAC;IACjD,CAAC;EACH;EAEA,MAAMW,WAAWA,CAAA,EAAG;IAClB,IAAI;MACF,IAAI,CAACzB,QAAQ,CAAC,sBAAsB,CAAC;MACrC,MAAMmB,KAAK,GAAG,MAAM,IAAI,CAACjC,cAAc,CAACuC,WAAW,CAAC,CAAC;MACrD,MAAM,IAAI,CAACvC,cAAc,CAAC8E,mBAAmB,CAAC7C,KAAK,CAAC;MACpD,IAAI,CAAC/B,MAAM,CAAC4C,IAAI,CAAC,cAAc,EAAE;QAAEb;MAAM,CAAC,CAAC;MAC3C,IAAI,CAACnB,QAAQ,CAAC,eAAe,CAAC;IAChC,CAAC,CAAC,OAAOc,KAAK,EAAE;MACd,IAAI,CAACd,QAAQ,CAAC,2BAA2Bc,KAAK,CAACC,OAAO,EAAE,CAAC;MACzD,MAAMD,KAAK;IACb;EACF;EAEA,MAAMI,WAAWA,CAACC,KAAK,EAAE;IACvB,IAAI;MACF,MAAM,IAAI,CAACjC,cAAc,CAAC+E,oBAAoB,CAAC9C,KAAK,CAAC;MACrD,MAAME,MAAM,GAAG,MAAM,IAAI,CAACnC,cAAc,CAACgF,YAAY,CAAC,CAAC;MACvD,MAAM,IAAI,CAAChF,cAAc,CAAC8E,mBAAmB,CAAC3C,MAAM,CAAC;MAErD,IAAI,CAACjC,MAAM,CAAC4C,IAAI,CAAC,eAAe,EAAE;QAAEX;MAAO,CAAC,CAAC;MAC7C,IAAI,CAACrB,QAAQ,CAAC,gBAAgB,CAAC;IACjC,CAAC,CAAC,OAAOc,KAAK,EAAE;MACd,IAAI,CAACd,QAAQ,CAAC,2BAA2Bc,KAAK,CAACC,OAAO,EAAE,CAAC;MACzD,MAAMD,KAAK;IACb;EACF;EAEA,MAAMM,YAAYA,CAACC,MAAM,EAAE;IACzB,IAAI;MACF,MAAM,IAAI,CAACnC,cAAc,CAAC+E,oBAAoB,CAAC5C,MAAM,CAAC;IACxD,CAAC,CAAC,OAAOP,KAAK,EAAE;MACd,IAAI,CAACd,QAAQ,CAAC,4BAA4Bc,KAAK,CAACC,OAAO,EAAE,CAAC;MAC1D,MAAMD,KAAK;IACb;EACF;EAEA,MAAMQ,kBAAkBA,CAACC,SAAS,EAAE;IAClC,IAAI;MACF,MAAM,IAAI,CAACrC,cAAc,CAACiF,eAAe,CAAC5C,SAAS,CAAC;IACtD,CAAC,CAAC,OAAOT,KAAK,EAAE;MACd,IAAI,CAACd,QAAQ,CAAC,iCAAiCc,KAAK,CAACC,OAAO,EAAE,CAAC;IACjE;EACF;EAEAqD,QAAQA,CAACnD,IAAI,EAAE;IACb,IAAI,IAAI,CAAC9B,WAAW,IAAI,IAAI,CAACA,WAAW,CAACkF,UAAU,KAAK,MAAM,EAAE;MAC9D,IAAI,CAAClF,WAAW,CAACmF,IAAI,CAACT,IAAI,CAACU,SAAS,CAACtD,IAAI,CAAC,CAAC;MAC3C,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EAEAuD,kBAAkBA,CAAA,EAAG;IAAA,IAAAC,qBAAA;IACnB,OAAO,EAAAA,qBAAA,OAAI,CAACvF,cAAc,cAAAuF,qBAAA,uBAAnBA,qBAAA,CAAqB1B,eAAe,KAAI,KAAK;EACtD;EAEApB,OAAOA,CAAA,EAAG;IACR,IAAI,CAAC3B,QAAQ,CAAC,qCAAqC,CAAC;IAEpD,IAAI,IAAI,CAACN,iBAAiB,EAAE;MAC1BsD,YAAY,CAAC,IAAI,CAACtD,iBAAiB,CAAC;IACtC;IAEA,IAAI,IAAI,CAACP,WAAW,EAAE;MACpB,IAAI,CAACA,WAAW,CAACuF,KAAK,CAAC,CAAC;MACxB,IAAI,CAACvF,WAAW,GAAG,IAAI;IACzB;IAEA,IAAI,IAAI,CAACD,cAAc,EAAE;MACvB,IAAI,CAACA,cAAc,CAACwF,KAAK,CAAC,CAAC;MAC3B,IAAI,CAACxF,cAAc,GAAG,IAAI;IAC5B;IAEA,IAAI,IAAI,CAACE,MAAM,EAAE;MACf,IAAI,CAACA,MAAM,CAACuF,UAAU,CAAC,CAAC;MACxB,IAAI,CAACvF,MAAM,GAAG,IAAI;IACpB;IAEA,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,MAAM,GAAG,KAAK;EACrB;EAEAU,QAAQA,CAACe,OAAO,EAAE;IAChB6D,OAAO,CAACC,GAAG,CAAC,YAAY9D,OAAO,EAAE,CAAC;IAClC,IAAI,IAAI,CAACtB,UAAU,EAAE;MACnB,IAAI,CAACA,UAAU,CAACsB,OAAO,CAAC;IAC1B;EACF;AACF;AAEA,eAAe/B,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}