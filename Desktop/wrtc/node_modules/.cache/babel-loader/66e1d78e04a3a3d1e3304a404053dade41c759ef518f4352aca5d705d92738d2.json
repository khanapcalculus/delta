{"ast":null,"code":"class WebRTCManager {\n  constructor() {\n    this.localConnection = null;\n    this.dataChannel = null;\n    this.isHost = false;\n    this.roomId = null;\n    this.onDataReceived = null;\n    this.onConnectionStateChange = null;\n    this.isConnected = false;\n    this.answerProcessed = false;\n    this.offerProcessed = false;\n    this.answerPolling = null;\n    this.offerPolling = null;\n\n    // Use Google's STUN servers for NAT traversal\n    this.iceServers = [{\n      urls: 'stun:stun.l.google.com:19302'\n    }, {\n      urls: 'stun:stun1.l.google.com:19302'\n    }, {\n      urls: 'stun:stun2.l.google.com:19302'\n    }];\n  }\n  async initialize(roomId, isHost = false) {\n    this.roomId = roomId;\n    this.isHost = isHost;\n    console.log(`ðŸš€ Initializing WebRTC - Room: ${roomId}, Role: ${isHost ? 'HOST' : 'GUEST'}`);\n\n    // Clear any existing data for this room first\n    this.cleanup();\n    try {\n      // Create RTCPeerConnection with optimized configuration\n      this.localConnection = new RTCPeerConnection({\n        iceServers: this.iceServers,\n        iceCandidatePoolSize: 10,\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require'\n      });\n\n      // Set up comprehensive connection state monitoring\n      this.localConnection.onconnectionstatechange = () => {\n        console.log('ðŸ”„ Connection state:', this.localConnection.connectionState);\n        const connected = this.localConnection.connectionState === 'connected';\n        this.isConnected = connected;\n        if (this.onConnectionStateChange) {\n          this.onConnectionStateChange(connected);\n        }\n      };\n      this.localConnection.oniceconnectionstatechange = () => {\n        console.log('ðŸ§Š ICE connection state:', this.localConnection.iceConnectionState);\n      };\n      this.localConnection.onicegatheringstatechange = () => {\n        console.log('ðŸ“¡ ICE gathering state:', this.localConnection.iceGatheringState);\n      };\n      this.localConnection.onsignalingstatechange = () => {\n        console.log('ðŸ“‹ Signaling state:', this.localConnection.signalingState);\n      };\n      if (isHost) {\n        await this.setupAsHost();\n      } else {\n        await this.setupAsGuest();\n      }\n    } catch (error) {\n      console.error('âŒ WebRTC initialization failed:', error);\n      throw error;\n    }\n  }\n  async setupAsHost() {\n    console.log('ðŸ”µ Setting up as HOST for room:', this.roomId);\n\n    // Create data channel with optimized settings\n    this.dataChannel = this.localConnection.createDataChannel('whiteboard', {\n      ordered: true,\n      // Ensure drawing data arrives in order\n      maxRetransmits: 3\n    });\n    this.setupDataChannel(this.dataChannel);\n\n    // Handle ICE candidates\n    this.localConnection.onicecandidate = event => {\n      if (event.candidate) {\n        console.log('ðŸ§Š Host ICE candidate generated');\n        this.storeIceCandidate(event.candidate, 'host');\n      } else {\n        console.log('âœ… Host ICE gathering complete');\n      }\n    };\n\n    // Create offer\n    console.log('ðŸ“ Creating offer...');\n    const offer = await this.localConnection.createOffer();\n    await this.localConnection.setLocalDescription(offer);\n\n    // Store offer in localStorage with detailed logging\n    const offerData = {\n      offer: offer,\n      timestamp: Date.now(),\n      roomId: this.roomId\n    };\n    localStorage.setItem(`offer_${this.roomId}`, JSON.stringify(offerData));\n    console.log('ðŸ’¾ Offer stored in localStorage:', offerData);\n    console.log('âœ… Host setup complete. Room ID:', this.roomId);\n    console.log('â³ Waiting for answer...');\n\n    // Listen for answer\n    this.waitForAnswer();\n  }\n  async setupAsGuest() {\n    console.log('ðŸŸ¢ Setting up as GUEST for room:', this.roomId);\n\n    // Handle ICE candidates\n    this.localConnection.onicecandidate = event => {\n      if (event.candidate) {\n        console.log('ðŸ§Š Guest ICE candidate generated');\n        this.storeIceCandidate(event.candidate, 'guest');\n      } else {\n        console.log('âœ… Guest ICE gathering complete');\n      }\n    };\n\n    // Wait for offer\n    console.log('ðŸ” Looking for offer...');\n    const offerData = await this.waitForOffer();\n    if (!offerData) {\n      throw new Error('No offer found for this room');\n    }\n    console.log('ðŸ“¥ Offer received, setting as remote description...');\n    console.log('ðŸ“‹ Current signaling state:', this.localConnection.signalingState);\n    try {\n      await this.localConnection.setRemoteDescription(offerData.offer);\n      console.log('âœ… Remote description (offer) set successfully');\n    } catch (error) {\n      console.error('âŒ Failed to set remote description (offer):', error);\n      throw error;\n    }\n\n    // Listen for data channel from host\n    this.localConnection.ondatachannel = event => {\n      console.log('ðŸ“¡ Data channel received from host');\n      this.dataChannel = event.channel;\n      this.setupDataChannel(this.dataChannel);\n    };\n\n    // Create answer\n    console.log('ðŸ“ Creating answer...');\n    const answer = await this.localConnection.createAnswer();\n    await this.localConnection.setLocalDescription(answer);\n\n    // Store answer with detailed logging\n    const answerData = {\n      answer: answer,\n      timestamp: Date.now(),\n      roomId: this.roomId\n    };\n    localStorage.setItem(`answer_${this.roomId}`, JSON.stringify(answerData));\n    console.log('ðŸ’¾ Answer stored in localStorage:', answerData);\n    console.log('âœ… Guest setup complete');\n\n    // Process stored ICE candidates from host\n    setTimeout(() => {\n      this.processStoredIceCandidates('host');\n    }, 1000);\n  }\n  setupDataChannel(channel) {\n    console.log('ðŸ”§ Setting up data channel...');\n    channel.onopen = () => {\n      console.log('ðŸŽ‰ DATA CHANNEL OPENED - CONNECTION ESTABLISHED!');\n      this.isConnected = true;\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(true);\n      }\n    };\n    channel.onclose = () => {\n      console.log('âŒ Data channel closed');\n      this.isConnected = false;\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(false);\n      }\n    };\n    channel.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('ðŸ“¨ Data received:', data.type);\n        if (this.onDataReceived) {\n          this.onDataReceived(data);\n        }\n      } catch (error) {\n        console.error('âŒ Failed to parse received data:', error);\n      }\n    };\n    channel.onerror = error => {\n      console.error('âŒ Data channel error:', error);\n    };\n  }\n  async waitForOffer() {\n    return new Promise((resolve, reject) => {\n      let attempts = 0;\n      const maxAttempts = 30; // Reduced to 30 seconds for faster feedback\n\n      this.offerPolling = setInterval(() => {\n        attempts++;\n        console.log(`ðŸ” Looking for offer... attempt ${attempts}/${maxAttempts}`);\n\n        // Debug: Show what's in localStorage\n        const keys = Object.keys(localStorage);\n        console.log('ðŸ“¦ LocalStorage keys:', keys.filter(k => k.includes(this.roomId)));\n        const offerData = localStorage.getItem(`offer_${this.roomId}`);\n        if (offerData) {\n          try {\n            const parsed = JSON.parse(offerData);\n            console.log('ðŸ“„ Found offer data:', parsed);\n\n            // Check if offer is not too old (10 minutes)\n            if (Date.now() - parsed.timestamp < 600000) {\n              console.log('âœ… Valid offer found!');\n              clearInterval(this.offerPolling);\n              this.offerProcessed = true;\n              resolve(parsed);\n              return;\n            } else {\n              console.log('âŒ Offer too old, removing...');\n              localStorage.removeItem(`offer_${this.roomId}`);\n            }\n          } catch (error) {\n            console.error('âŒ Failed to parse offer:', error);\n          }\n        } else {\n          console.log('âŒ No offer found in localStorage');\n        }\n        if (attempts >= maxAttempts) {\n          clearInterval(this.offerPolling);\n          reject(new Error('Timeout waiting for offer'));\n        }\n      }, 1000);\n    });\n  }\n  async waitForAnswer() {\n    let attempts = 0;\n    const maxAttempts = 30;\n    this.answerPolling = setInterval(async () => {\n      attempts++;\n      console.log(`ðŸ” Looking for answer... attempt ${attempts}/${maxAttempts}`);\n\n      // Debug: Show what's in localStorage\n      const keys = Object.keys(localStorage);\n      console.log('ðŸ“¦ LocalStorage keys:', keys.filter(k => k.includes(this.roomId)));\n      const answerData = localStorage.getItem(`answer_${this.roomId}`);\n      if (answerData) {\n        try {\n          const parsed = JSON.parse(answerData);\n          console.log('ðŸ“„ Found answer data:', parsed);\n\n          // Check connection state before setting remote description\n          console.log('ðŸ“‹ Current signaling state:', this.localConnection.signalingState);\n          if (this.localConnection.signalingState === 'have-local-offer') {\n            console.log('âœ… Answer received, setting as remote description...');\n            await this.localConnection.setRemoteDescription(parsed.answer);\n            clearInterval(this.answerPolling);\n            this.answerProcessed = true;\n\n            // Process guest ICE candidates\n            setTimeout(() => {\n              this.processStoredIceCandidates('guest');\n            }, 1000);\n            console.log('âœ… Remote description (answer) set successfully');\n            return;\n          } else {\n            console.log('âš ï¸ Wrong signaling state for answer:', this.localConnection.signalingState);\n          }\n        } catch (error) {\n          console.error('âŒ Failed to set remote description (answer):', error);\n          clearInterval(this.answerPolling);\n        }\n      } else {\n        console.log('âŒ No answer found in localStorage');\n      }\n      if (attempts >= maxAttempts) {\n        clearInterval(this.answerPolling);\n        console.error('âŒ Timeout waiting for answer');\n      }\n    }, 1000);\n  }\n  storeIceCandidate(candidate, role) {\n    const key = `ice_${this.roomId}_${role}`;\n    const existing = JSON.parse(localStorage.getItem(key) || '[]');\n    existing.push({\n      candidate: candidate,\n      timestamp: Date.now()\n    });\n    localStorage.setItem(key, JSON.stringify(existing));\n    console.log(`ðŸ’¾ Stored ICE candidate for ${role}`);\n  }\n  async processStoredIceCandidates(role) {\n    const key = `ice_${this.roomId}_${role}`;\n    const candidates = JSON.parse(localStorage.getItem(key) || '[]');\n    console.log(`ðŸ§Š Processing ${candidates.length} ICE candidates for ${role}`);\n    for (const candidateData of candidates) {\n      try {\n        if (this.localConnection.signalingState !== 'closed') {\n          await this.localConnection.addIceCandidate(candidateData.candidate);\n          console.log(`âœ… Added ICE candidate for ${role}`);\n        }\n      } catch (error) {\n        console.error(`âŒ Failed to add ICE candidate for ${role}:`, error);\n      }\n    }\n  }\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      try {\n        this.dataChannel.send(JSON.stringify(data));\n      } catch (error) {\n        console.error('âŒ Failed to send data:', error);\n      }\n    } else {\n      var _this$dataChannel;\n      console.warn('âš ï¸ Data channel not ready, state:', ((_this$dataChannel = this.dataChannel) === null || _this$dataChannel === void 0 ? void 0 : _this$dataChannel.readyState) || 'null');\n    }\n  }\n  cleanup() {\n    if (this.roomId) {\n      const keys = [`offer_${this.roomId}`, `answer_${this.roomId}`, `ice_${this.roomId}_host`, `ice_${this.roomId}_guest`];\n      keys.forEach(key => localStorage.removeItem(key));\n      console.log('ðŸ§¹ Cleaned up localStorage for room:', this.roomId);\n    }\n  }\n  disconnect() {\n    console.log('ðŸ”Œ Disconnecting WebRTC...');\n\n    // Clear polling intervals\n    if (this.answerPolling) {\n      clearInterval(this.answerPolling);\n      this.answerPolling = null;\n    }\n    if (this.offerPolling) {\n      clearInterval(this.offerPolling);\n      this.offerPolling = null;\n    }\n    this.isConnected = false;\n    this.answerProcessed = false;\n    this.offerProcessed = false;\n    if (this.dataChannel) {\n      this.dataChannel.close();\n    }\n    if (this.localConnection) {\n      this.localConnection.close();\n    }\n    this.cleanup();\n    console.log('âœ… Disconnection complete');\n  }\n}\nexport default WebRTCManager;","map":{"version":3,"names":["WebRTCManager","constructor","localConnection","dataChannel","isHost","roomId","onDataReceived","onConnectionStateChange","isConnected","answerProcessed","offerProcessed","answerPolling","offerPolling","iceServers","urls","initialize","console","log","cleanup","RTCPeerConnection","iceCandidatePoolSize","bundlePolicy","rtcpMuxPolicy","onconnectionstatechange","connectionState","connected","oniceconnectionstatechange","iceConnectionState","onicegatheringstatechange","iceGatheringState","onsignalingstatechange","signalingState","setupAsHost","setupAsGuest","error","createDataChannel","ordered","maxRetransmits","setupDataChannel","onicecandidate","event","candidate","storeIceCandidate","offer","createOffer","setLocalDescription","offerData","timestamp","Date","now","localStorage","setItem","JSON","stringify","waitForAnswer","waitForOffer","Error","setRemoteDescription","ondatachannel","channel","answer","createAnswer","answerData","setTimeout","processStoredIceCandidates","onopen","onclose","onmessage","data","parse","type","onerror","Promise","resolve","reject","attempts","maxAttempts","setInterval","keys","Object","filter","k","includes","getItem","parsed","clearInterval","removeItem","role","key","existing","push","candidates","length","candidateData","addIceCandidate","sendData","readyState","send","_this$dataChannel","warn","forEach","disconnect","close"],"sources":["C:/Users/eniac/Desktop/wrtc/src/services/WebRTCManager.js"],"sourcesContent":["class WebRTCManager {\n  constructor() {\n    this.localConnection = null;\n    this.dataChannel = null;\n    this.isHost = false;\n    this.roomId = null;\n    this.onDataReceived = null;\n    this.onConnectionStateChange = null;\n    this.isConnected = false;\n    this.answerProcessed = false;\n    this.offerProcessed = false;\n    this.answerPolling = null;\n    this.offerPolling = null;\n    \n    // Use Google's STUN servers for NAT traversal\n    this.iceServers = [\n      { urls: 'stun:stun.l.google.com:19302' },\n      { urls: 'stun:stun1.l.google.com:19302' },\n      { urls: 'stun:stun2.l.google.com:19302' }\n    ];\n  }\n\n  async initialize(roomId, isHost = false) {\n    this.roomId = roomId;\n    this.isHost = isHost;\n    \n    console.log(`ðŸš€ Initializing WebRTC - Room: ${roomId}, Role: ${isHost ? 'HOST' : 'GUEST'}`);\n    \n    // Clear any existing data for this room first\n    this.cleanup();\n    \n    try {\n      // Create RTCPeerConnection with optimized configuration\n      this.localConnection = new RTCPeerConnection({\n        iceServers: this.iceServers,\n        iceCandidatePoolSize: 10,\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require'\n      });\n\n      // Set up comprehensive connection state monitoring\n      this.localConnection.onconnectionstatechange = () => {\n        console.log('ðŸ”„ Connection state:', this.localConnection.connectionState);\n        const connected = this.localConnection.connectionState === 'connected';\n        this.isConnected = connected;\n        if (this.onConnectionStateChange) {\n          this.onConnectionStateChange(connected);\n        }\n      };\n\n      this.localConnection.oniceconnectionstatechange = () => {\n        console.log('ðŸ§Š ICE connection state:', this.localConnection.iceConnectionState);\n      };\n\n      this.localConnection.onicegatheringstatechange = () => {\n        console.log('ðŸ“¡ ICE gathering state:', this.localConnection.iceGatheringState);\n      };\n\n      this.localConnection.onsignalingstatechange = () => {\n        console.log('ðŸ“‹ Signaling state:', this.localConnection.signalingState);\n      };\n\n      if (isHost) {\n        await this.setupAsHost();\n      } else {\n        await this.setupAsGuest();\n      }\n    } catch (error) {\n      console.error('âŒ WebRTC initialization failed:', error);\n      throw error;\n    }\n  }\n\n  async setupAsHost() {\n    console.log('ðŸ”µ Setting up as HOST for room:', this.roomId);\n    \n    // Create data channel with optimized settings\n    this.dataChannel = this.localConnection.createDataChannel('whiteboard', {\n      ordered: true,  // Ensure drawing data arrives in order\n      maxRetransmits: 3\n    });\n    \n    this.setupDataChannel(this.dataChannel);\n    \n    // Handle ICE candidates\n    this.localConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log('ðŸ§Š Host ICE candidate generated');\n        this.storeIceCandidate(event.candidate, 'host');\n      } else {\n        console.log('âœ… Host ICE gathering complete');\n      }\n    };\n    \n    // Create offer\n    console.log('ðŸ“ Creating offer...');\n    const offer = await this.localConnection.createOffer();\n    await this.localConnection.setLocalDescription(offer);\n    \n    // Store offer in localStorage with detailed logging\n    const offerData = {\n      offer: offer,\n      timestamp: Date.now(),\n      roomId: this.roomId\n    };\n    \n    localStorage.setItem(`offer_${this.roomId}`, JSON.stringify(offerData));\n    console.log('ðŸ’¾ Offer stored in localStorage:', offerData);\n    \n    console.log('âœ… Host setup complete. Room ID:', this.roomId);\n    console.log('â³ Waiting for answer...');\n    \n    // Listen for answer\n    this.waitForAnswer();\n  }\n\n  async setupAsGuest() {\n    console.log('ðŸŸ¢ Setting up as GUEST for room:', this.roomId);\n    \n    // Handle ICE candidates\n    this.localConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log('ðŸ§Š Guest ICE candidate generated');\n        this.storeIceCandidate(event.candidate, 'guest');\n      } else {\n        console.log('âœ… Guest ICE gathering complete');\n      }\n    };\n    \n    // Wait for offer\n    console.log('ðŸ” Looking for offer...');\n    const offerData = await this.waitForOffer();\n    if (!offerData) {\n      throw new Error('No offer found for this room');\n    }\n    \n    console.log('ðŸ“¥ Offer received, setting as remote description...');\n    console.log('ðŸ“‹ Current signaling state:', this.localConnection.signalingState);\n    \n    try {\n      await this.localConnection.setRemoteDescription(offerData.offer);\n      console.log('âœ… Remote description (offer) set successfully');\n    } catch (error) {\n      console.error('âŒ Failed to set remote description (offer):', error);\n      throw error;\n    }\n    \n    // Listen for data channel from host\n    this.localConnection.ondatachannel = (event) => {\n      console.log('ðŸ“¡ Data channel received from host');\n      this.dataChannel = event.channel;\n      this.setupDataChannel(this.dataChannel);\n    };\n    \n    // Create answer\n    console.log('ðŸ“ Creating answer...');\n    const answer = await this.localConnection.createAnswer();\n    await this.localConnection.setLocalDescription(answer);\n    \n    // Store answer with detailed logging\n    const answerData = {\n      answer: answer,\n      timestamp: Date.now(),\n      roomId: this.roomId\n    };\n    \n    localStorage.setItem(`answer_${this.roomId}`, JSON.stringify(answerData));\n    console.log('ðŸ’¾ Answer stored in localStorage:', answerData);\n    \n    console.log('âœ… Guest setup complete');\n    \n    // Process stored ICE candidates from host\n    setTimeout(() => {\n      this.processStoredIceCandidates('host');\n    }, 1000);\n  }\n\n  setupDataChannel(channel) {\n    console.log('ðŸ”§ Setting up data channel...');\n    \n    channel.onopen = () => {\n      console.log('ðŸŽ‰ DATA CHANNEL OPENED - CONNECTION ESTABLISHED!');\n      this.isConnected = true;\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(true);\n      }\n    };\n    \n    channel.onclose = () => {\n      console.log('âŒ Data channel closed');\n      this.isConnected = false;\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(false);\n      }\n    };\n    \n    channel.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('ðŸ“¨ Data received:', data.type);\n        if (this.onDataReceived) {\n          this.onDataReceived(data);\n        }\n      } catch (error) {\n        console.error('âŒ Failed to parse received data:', error);\n      }\n    };\n    \n    channel.onerror = (error) => {\n      console.error('âŒ Data channel error:', error);\n    };\n  }\n\n  async waitForOffer() {\n    return new Promise((resolve, reject) => {\n      let attempts = 0;\n      const maxAttempts = 30; // Reduced to 30 seconds for faster feedback\n      \n      this.offerPolling = setInterval(() => {\n        attempts++;\n        console.log(`ðŸ” Looking for offer... attempt ${attempts}/${maxAttempts}`);\n        \n        // Debug: Show what's in localStorage\n        const keys = Object.keys(localStorage);\n        console.log('ðŸ“¦ LocalStorage keys:', keys.filter(k => k.includes(this.roomId)));\n        \n        const offerData = localStorage.getItem(`offer_${this.roomId}`);\n        if (offerData) {\n          try {\n            const parsed = JSON.parse(offerData);\n            console.log('ðŸ“„ Found offer data:', parsed);\n            \n            // Check if offer is not too old (10 minutes)\n            if (Date.now() - parsed.timestamp < 600000) {\n              console.log('âœ… Valid offer found!');\n              clearInterval(this.offerPolling);\n              this.offerProcessed = true;\n              resolve(parsed);\n              return;\n            } else {\n              console.log('âŒ Offer too old, removing...');\n              localStorage.removeItem(`offer_${this.roomId}`);\n            }\n          } catch (error) {\n            console.error('âŒ Failed to parse offer:', error);\n          }\n        } else {\n          console.log('âŒ No offer found in localStorage');\n        }\n        \n        if (attempts >= maxAttempts) {\n          clearInterval(this.offerPolling);\n          reject(new Error('Timeout waiting for offer'));\n        }\n      }, 1000);\n    });\n  }\n\n  async waitForAnswer() {\n    let attempts = 0;\n    const maxAttempts = 30;\n    \n    this.answerPolling = setInterval(async () => {\n      attempts++;\n      console.log(`ðŸ” Looking for answer... attempt ${attempts}/${maxAttempts}`);\n      \n      // Debug: Show what's in localStorage\n      const keys = Object.keys(localStorage);\n      console.log('ðŸ“¦ LocalStorage keys:', keys.filter(k => k.includes(this.roomId)));\n      \n      const answerData = localStorage.getItem(`answer_${this.roomId}`);\n      if (answerData) {\n        try {\n          const parsed = JSON.parse(answerData);\n          console.log('ðŸ“„ Found answer data:', parsed);\n          \n          // Check connection state before setting remote description\n          console.log('ðŸ“‹ Current signaling state:', this.localConnection.signalingState);\n          \n          if (this.localConnection.signalingState === 'have-local-offer') {\n            console.log('âœ… Answer received, setting as remote description...');\n            await this.localConnection.setRemoteDescription(parsed.answer);\n            \n            clearInterval(this.answerPolling);\n            this.answerProcessed = true;\n            \n            // Process guest ICE candidates\n            setTimeout(() => {\n              this.processStoredIceCandidates('guest');\n            }, 1000);\n            \n            console.log('âœ… Remote description (answer) set successfully');\n            return;\n          } else {\n            console.log('âš ï¸ Wrong signaling state for answer:', this.localConnection.signalingState);\n          }\n        } catch (error) {\n          console.error('âŒ Failed to set remote description (answer):', error);\n          clearInterval(this.answerPolling);\n        }\n      } else {\n        console.log('âŒ No answer found in localStorage');\n      }\n      \n      if (attempts >= maxAttempts) {\n        clearInterval(this.answerPolling);\n        console.error('âŒ Timeout waiting for answer');\n      }\n    }, 1000);\n  }\n\n  storeIceCandidate(candidate, role) {\n    const key = `ice_${this.roomId}_${role}`;\n    const existing = JSON.parse(localStorage.getItem(key) || '[]');\n    existing.push({\n      candidate: candidate,\n      timestamp: Date.now()\n    });\n    localStorage.setItem(key, JSON.stringify(existing));\n    console.log(`ðŸ’¾ Stored ICE candidate for ${role}`);\n  }\n\n  async processStoredIceCandidates(role) {\n    const key = `ice_${this.roomId}_${role}`;\n    const candidates = JSON.parse(localStorage.getItem(key) || '[]');\n    \n    console.log(`ðŸ§Š Processing ${candidates.length} ICE candidates for ${role}`);\n    \n    for (const candidateData of candidates) {\n      try {\n        if (this.localConnection.signalingState !== 'closed') {\n          await this.localConnection.addIceCandidate(candidateData.candidate);\n          console.log(`âœ… Added ICE candidate for ${role}`);\n        }\n      } catch (error) {\n        console.error(`âŒ Failed to add ICE candidate for ${role}:`, error);\n      }\n    }\n  }\n\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      try {\n        this.dataChannel.send(JSON.stringify(data));\n      } catch (error) {\n        console.error('âŒ Failed to send data:', error);\n      }\n    } else {\n      console.warn('âš ï¸ Data channel not ready, state:', this.dataChannel?.readyState || 'null');\n    }\n  }\n\n  cleanup() {\n    if (this.roomId) {\n      const keys = [`offer_${this.roomId}`, `answer_${this.roomId}`, `ice_${this.roomId}_host`, `ice_${this.roomId}_guest`];\n      keys.forEach(key => localStorage.removeItem(key));\n      console.log('ðŸ§¹ Cleaned up localStorage for room:', this.roomId);\n    }\n  }\n\n  disconnect() {\n    console.log('ðŸ”Œ Disconnecting WebRTC...');\n    \n    // Clear polling intervals\n    if (this.answerPolling) {\n      clearInterval(this.answerPolling);\n      this.answerPolling = null;\n    }\n    if (this.offerPolling) {\n      clearInterval(this.offerPolling);\n      this.offerPolling = null;\n    }\n    \n    this.isConnected = false;\n    this.answerProcessed = false;\n    this.offerProcessed = false;\n    \n    if (this.dataChannel) {\n      this.dataChannel.close();\n    }\n    if (this.localConnection) {\n      this.localConnection.close();\n    }\n    \n    this.cleanup();\n    console.log('âœ… Disconnection complete');\n  }\n}\n\nexport default WebRTCManager; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}