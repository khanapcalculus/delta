{"ast":null,"code":"class WebRTCManager {\n  constructor() {\n    this.localConnection = null;\n    this.dataChannel = null;\n    this.isHost = false;\n    this.roomId = null;\n    this.onDataReceived = null;\n    this.onConnectionStateChange = null;\n\n    // Use Google's STUN servers for NAT traversal\n    this.iceServers = [{\n      urls: 'stun:stun.l.google.com:19302'\n    }, {\n      urls: 'stun:stun1.l.google.com:19302'\n    }, {\n      urls: 'stun:stun2.l.google.com:19302'\n    }];\n  }\n  async initialize(roomId, isHost = false) {\n    this.roomId = roomId;\n    this.isHost = isHost;\n    try {\n      // Create RTCPeerConnection with optimized configuration\n      this.localConnection = new RTCPeerConnection({\n        iceServers: this.iceServers,\n        iceCandidatePoolSize: 10,\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require'\n      });\n\n      // Set up comprehensive connection state monitoring\n      this.localConnection.onconnectionstatechange = () => {\n        console.log('Connection state:', this.localConnection.connectionState);\n        if (this.onConnectionStateChange) {\n          const isConnected = this.localConnection.connectionState === 'connected';\n          this.onConnectionStateChange(isConnected);\n        }\n      };\n      this.localConnection.oniceconnectionstatechange = () => {\n        console.log('ICE connection state:', this.localConnection.iceConnectionState);\n      };\n      this.localConnection.onicegatheringstatechange = () => {\n        console.log('ICE gathering state:', this.localConnection.iceGatheringState);\n      };\n      if (isHost) {\n        await this.setupAsHost();\n      } else {\n        await this.setupAsGuest();\n      }\n    } catch (error) {\n      console.error('WebRTC initialization failed:', error);\n      throw error;\n    }\n  }\n  async setupAsHost() {\n    // Create data channel with optimized settings\n    this.dataChannel = this.localConnection.createDataChannel('whiteboard', {\n      ordered: true,\n      // Ensure drawing data arrives in order\n      maxRetransmits: 3\n    });\n    this.setupDataChannel(this.dataChannel);\n\n    // Handle ICE candidates first\n    this.localConnection.onicecandidate = event => {\n      if (event.candidate) {\n        console.log('Host ICE candidate:', event.candidate);\n        this.storeIceCandidate(event.candidate, 'host');\n      } else {\n        console.log('Host ICE gathering complete');\n      }\n    };\n\n    // Create offer\n    const offer = await this.localConnection.createOffer();\n    await this.localConnection.setLocalDescription(offer);\n\n    // Store offer in localStorage\n    localStorage.setItem(`offer_${this.roomId}`, JSON.stringify({\n      offer: offer,\n      timestamp: Date.now()\n    }));\n    console.log('Host setup complete. Room ID:', this.roomId);\n    console.log('Offer stored, waiting for answer...');\n\n    // Listen for answer\n    this.waitForAnswer();\n  }\n  async setupAsGuest() {\n    console.log('Guest setup starting, waiting for offer...');\n\n    // Handle ICE candidates\n    this.localConnection.onicecandidate = event => {\n      if (event.candidate) {\n        console.log('Guest ICE candidate:', event.candidate);\n        this.storeIceCandidate(event.candidate, 'guest');\n      } else {\n        console.log('Guest ICE gathering complete');\n      }\n    };\n\n    // Wait for offer\n    const offerData = await this.waitForOffer();\n    if (!offerData) {\n      throw new Error('No offer found for this room');\n    }\n    console.log('Offer received, setting remote description...');\n    await this.localConnection.setRemoteDescription(offerData.offer);\n\n    // Listen for data channel\n    this.localConnection.ondatachannel = event => {\n      console.log('Data channel received from host');\n      this.dataChannel = event.channel;\n      this.setupDataChannel(this.dataChannel);\n    };\n\n    // Create answer\n    const answer = await this.localConnection.createAnswer();\n    await this.localConnection.setLocalDescription(answer);\n\n    // Store answer\n    localStorage.setItem(`answer_${this.roomId}`, JSON.stringify({\n      answer: answer,\n      timestamp: Date.now()\n    }));\n    console.log('Answer created and stored');\n\n    // Process stored ICE candidates from host\n    setTimeout(() => {\n      this.processStoredIceCandidates('host');\n    }, 1000);\n  }\n  setupDataChannel(channel) {\n    console.log('Setting up data channel...');\n    channel.onopen = () => {\n      console.log('✅ Data channel opened - Connection established!');\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(true);\n      }\n    };\n    channel.onclose = () => {\n      console.log('❌ Data channel closed');\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(false);\n      }\n    };\n    channel.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        if (this.onDataReceived) {\n          this.onDataReceived(data);\n        }\n      } catch (error) {\n        console.error('Failed to parse received data:', error);\n      }\n    };\n    channel.onerror = error => {\n      console.error('Data channel error:', error);\n    };\n\n    // Monitor channel state\n    const checkChannelState = () => {\n      console.log('Data channel state:', channel.readyState);\n      if (channel.readyState !== 'closed') {\n        setTimeout(checkChannelState, 5000);\n      }\n    };\n    setTimeout(checkChannelState, 1000);\n  }\n  async waitForOffer() {\n    return new Promise((resolve, reject) => {\n      let attempts = 0;\n      const maxAttempts = 60; // Wait up to 60 seconds\n\n      const checkForOffer = () => {\n        attempts++;\n        console.log(`Checking for offer... attempt ${attempts}/${maxAttempts}`);\n        const offerData = localStorage.getItem(`offer_${this.roomId}`);\n        if (offerData) {\n          try {\n            const parsed = JSON.parse(offerData);\n            // Check if offer is not too old (10 minutes)\n            if (Date.now() - parsed.timestamp < 600000) {\n              console.log('✅ Valid offer found!');\n              resolve(parsed);\n              return;\n            } else {\n              console.log('❌ Offer too old, removing...');\n              localStorage.removeItem(`offer_${this.roomId}`);\n            }\n          } catch (error) {\n            console.error('Failed to parse offer:', error);\n          }\n        }\n        if (attempts >= maxAttempts) {\n          reject(new Error('Timeout waiting for offer'));\n          return;\n        }\n        setTimeout(checkForOffer, 1000);\n      };\n      checkForOffer();\n    });\n  }\n  async waitForAnswer() {\n    let attempts = 0;\n    const maxAttempts = 60; // Wait up to 60 seconds\n\n    const checkForAnswer = async () => {\n      attempts++;\n      console.log(`Checking for answer... attempt ${attempts}/${maxAttempts}`);\n      const answerData = localStorage.getItem(`answer_${this.roomId}`);\n      if (answerData) {\n        try {\n          const parsed = JSON.parse(answerData);\n          console.log('✅ Answer received, setting remote description...');\n          await this.localConnection.setRemoteDescription(parsed.answer);\n\n          // Process guest ICE candidates\n          setTimeout(() => {\n            this.processStoredIceCandidates('guest');\n          }, 1000);\n          console.log('Remote description set successfully');\n          return;\n        } catch (error) {\n          console.error('Failed to set remote description:', error);\n        }\n      }\n      if (attempts < maxAttempts) {\n        setTimeout(checkForAnswer, 1000);\n      } else {\n        console.error('Timeout waiting for answer');\n      }\n    };\n    checkForAnswer();\n  }\n  storeIceCandidate(candidate, role) {\n    const key = `ice_${this.roomId}_${role}`;\n    const existing = JSON.parse(localStorage.getItem(key) || '[]');\n    existing.push({\n      candidate: candidate,\n      timestamp: Date.now()\n    });\n    localStorage.setItem(key, JSON.stringify(existing));\n    console.log(`Stored ICE candidate for ${role}:`, candidate.candidate);\n  }\n  async processStoredIceCandidates(role) {\n    const key = `ice_${this.roomId}_${role}`;\n    const candidates = JSON.parse(localStorage.getItem(key) || '[]');\n    console.log(`Processing ${candidates.length} ICE candidates for ${role}`);\n    for (const candidateData of candidates) {\n      try {\n        await this.localConnection.addIceCandidate(candidateData.candidate);\n        console.log(`✅ Added ICE candidate for ${role}`);\n      } catch (error) {\n        console.error(`Failed to add ICE candidate for ${role}:`, error);\n      }\n    }\n\n    // Continue polling for new candidates, but less frequently\n    setTimeout(() => {\n      const newCandidates = JSON.parse(localStorage.getItem(key) || '[]');\n      if (newCandidates.length > candidates.length) {\n        this.processStoredIceCandidates(role);\n      } else {\n        // Check again in 5 seconds if no new candidates\n        setTimeout(() => this.processStoredIceCandidates(role), 5000);\n      }\n    }, 2000);\n  }\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      try {\n        this.dataChannel.send(JSON.stringify(data));\n      } catch (error) {\n        console.error('Failed to send data:', error);\n      }\n    } else {\n      var _this$dataChannel;\n      console.warn('Data channel not ready, state:', ((_this$dataChannel = this.dataChannel) === null || _this$dataChannel === void 0 ? void 0 : _this$dataChannel.readyState) || 'null');\n    }\n  }\n  disconnect() {\n    console.log('Disconnecting WebRTC...');\n    if (this.dataChannel) {\n      this.dataChannel.close();\n    }\n    if (this.localConnection) {\n      this.localConnection.close();\n    }\n\n    // Clean up localStorage\n    if (this.roomId) {\n      localStorage.removeItem(`offer_${this.roomId}`);\n      localStorage.removeItem(`answer_${this.roomId}`);\n      localStorage.removeItem(`ice_${this.roomId}_host`);\n      localStorage.removeItem(`ice_${this.roomId}_guest`);\n      console.log('Cleaned up localStorage for room:', this.roomId);\n    }\n  }\n}\nexport default WebRTCManager;","map":{"version":3,"names":["WebRTCManager","constructor","localConnection","dataChannel","isHost","roomId","onDataReceived","onConnectionStateChange","iceServers","urls","initialize","RTCPeerConnection","iceCandidatePoolSize","bundlePolicy","rtcpMuxPolicy","onconnectionstatechange","console","log","connectionState","isConnected","oniceconnectionstatechange","iceConnectionState","onicegatheringstatechange","iceGatheringState","setupAsHost","setupAsGuest","error","createDataChannel","ordered","maxRetransmits","setupDataChannel","onicecandidate","event","candidate","storeIceCandidate","offer","createOffer","setLocalDescription","localStorage","setItem","JSON","stringify","timestamp","Date","now","waitForAnswer","offerData","waitForOffer","Error","setRemoteDescription","ondatachannel","channel","answer","createAnswer","setTimeout","processStoredIceCandidates","onopen","onclose","onmessage","data","parse","onerror","checkChannelState","readyState","Promise","resolve","reject","attempts","maxAttempts","checkForOffer","getItem","parsed","removeItem","checkForAnswer","answerData","role","key","existing","push","candidates","length","candidateData","addIceCandidate","newCandidates","sendData","send","_this$dataChannel","warn","disconnect","close"],"sources":["C:/Users/eniac/Desktop/wrtc/src/services/WebRTCManager.js"],"sourcesContent":["class WebRTCManager {\n  constructor() {\n    this.localConnection = null;\n    this.dataChannel = null;\n    this.isHost = false;\n    this.roomId = null;\n    this.onDataReceived = null;\n    this.onConnectionStateChange = null;\n    \n    // Use Google's STUN servers for NAT traversal\n    this.iceServers = [\n      { urls: 'stun:stun.l.google.com:19302' },\n      { urls: 'stun:stun1.l.google.com:19302' },\n      { urls: 'stun:stun2.l.google.com:19302' }\n    ];\n  }\n\n  async initialize(roomId, isHost = false) {\n    this.roomId = roomId;\n    this.isHost = isHost;\n    \n    try {\n      // Create RTCPeerConnection with optimized configuration\n      this.localConnection = new RTCPeerConnection({\n        iceServers: this.iceServers,\n        iceCandidatePoolSize: 10,\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require'\n      });\n\n      // Set up comprehensive connection state monitoring\n      this.localConnection.onconnectionstatechange = () => {\n        console.log('Connection state:', this.localConnection.connectionState);\n        if (this.onConnectionStateChange) {\n          const isConnected = this.localConnection.connectionState === 'connected';\n          this.onConnectionStateChange(isConnected);\n        }\n      };\n\n      this.localConnection.oniceconnectionstatechange = () => {\n        console.log('ICE connection state:', this.localConnection.iceConnectionState);\n      };\n\n      this.localConnection.onicegatheringstatechange = () => {\n        console.log('ICE gathering state:', this.localConnection.iceGatheringState);\n      };\n\n      if (isHost) {\n        await this.setupAsHost();\n      } else {\n        await this.setupAsGuest();\n      }\n    } catch (error) {\n      console.error('WebRTC initialization failed:', error);\n      throw error;\n    }\n  }\n\n  async setupAsHost() {\n    // Create data channel with optimized settings\n    this.dataChannel = this.localConnection.createDataChannel('whiteboard', {\n      ordered: true,  // Ensure drawing data arrives in order\n      maxRetransmits: 3\n    });\n    \n    this.setupDataChannel(this.dataChannel);\n    \n    // Handle ICE candidates first\n    this.localConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log('Host ICE candidate:', event.candidate);\n        this.storeIceCandidate(event.candidate, 'host');\n      } else {\n        console.log('Host ICE gathering complete');\n      }\n    };\n    \n    // Create offer\n    const offer = await this.localConnection.createOffer();\n    await this.localConnection.setLocalDescription(offer);\n    \n    // Store offer in localStorage\n    localStorage.setItem(`offer_${this.roomId}`, JSON.stringify({\n      offer: offer,\n      timestamp: Date.now()\n    }));\n    \n    console.log('Host setup complete. Room ID:', this.roomId);\n    console.log('Offer stored, waiting for answer...');\n    \n    // Listen for answer\n    this.waitForAnswer();\n  }\n\n  async setupAsGuest() {\n    console.log('Guest setup starting, waiting for offer...');\n    \n    // Handle ICE candidates\n    this.localConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log('Guest ICE candidate:', event.candidate);\n        this.storeIceCandidate(event.candidate, 'guest');\n      } else {\n        console.log('Guest ICE gathering complete');\n      }\n    };\n    \n    // Wait for offer\n    const offerData = await this.waitForOffer();\n    if (!offerData) {\n      throw new Error('No offer found for this room');\n    }\n    \n    console.log('Offer received, setting remote description...');\n    await this.localConnection.setRemoteDescription(offerData.offer);\n    \n    // Listen for data channel\n    this.localConnection.ondatachannel = (event) => {\n      console.log('Data channel received from host');\n      this.dataChannel = event.channel;\n      this.setupDataChannel(this.dataChannel);\n    };\n    \n    // Create answer\n    const answer = await this.localConnection.createAnswer();\n    await this.localConnection.setLocalDescription(answer);\n    \n    // Store answer\n    localStorage.setItem(`answer_${this.roomId}`, JSON.stringify({\n      answer: answer,\n      timestamp: Date.now()\n    }));\n    \n    console.log('Answer created and stored');\n    \n    // Process stored ICE candidates from host\n    setTimeout(() => {\n      this.processStoredIceCandidates('host');\n    }, 1000);\n  }\n\n  setupDataChannel(channel) {\n    console.log('Setting up data channel...');\n    \n    channel.onopen = () => {\n      console.log('✅ Data channel opened - Connection established!');\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(true);\n      }\n    };\n    \n    channel.onclose = () => {\n      console.log('❌ Data channel closed');\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(false);\n      }\n    };\n    \n    channel.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        if (this.onDataReceived) {\n          this.onDataReceived(data);\n        }\n      } catch (error) {\n        console.error('Failed to parse received data:', error);\n      }\n    };\n    \n    channel.onerror = (error) => {\n      console.error('Data channel error:', error);\n    };\n\n    // Monitor channel state\n    const checkChannelState = () => {\n      console.log('Data channel state:', channel.readyState);\n      if (channel.readyState !== 'closed') {\n        setTimeout(checkChannelState, 5000);\n      }\n    };\n    setTimeout(checkChannelState, 1000);\n  }\n\n  async waitForOffer() {\n    return new Promise((resolve, reject) => {\n      let attempts = 0;\n      const maxAttempts = 60; // Wait up to 60 seconds\n      \n      const checkForOffer = () => {\n        attempts++;\n        console.log(`Checking for offer... attempt ${attempts}/${maxAttempts}`);\n        \n        const offerData = localStorage.getItem(`offer_${this.roomId}`);\n        if (offerData) {\n          try {\n            const parsed = JSON.parse(offerData);\n            // Check if offer is not too old (10 minutes)\n            if (Date.now() - parsed.timestamp < 600000) {\n              console.log('✅ Valid offer found!');\n              resolve(parsed);\n              return;\n            } else {\n              console.log('❌ Offer too old, removing...');\n              localStorage.removeItem(`offer_${this.roomId}`);\n            }\n          } catch (error) {\n            console.error('Failed to parse offer:', error);\n          }\n        }\n        \n        if (attempts >= maxAttempts) {\n          reject(new Error('Timeout waiting for offer'));\n          return;\n        }\n        \n        setTimeout(checkForOffer, 1000);\n      };\n      checkForOffer();\n    });\n  }\n\n  async waitForAnswer() {\n    let attempts = 0;\n    const maxAttempts = 60; // Wait up to 60 seconds\n    \n    const checkForAnswer = async () => {\n      attempts++;\n      console.log(`Checking for answer... attempt ${attempts}/${maxAttempts}`);\n      \n      const answerData = localStorage.getItem(`answer_${this.roomId}`);\n      if (answerData) {\n        try {\n          const parsed = JSON.parse(answerData);\n          console.log('✅ Answer received, setting remote description...');\n          await this.localConnection.setRemoteDescription(parsed.answer);\n          \n          // Process guest ICE candidates\n          setTimeout(() => {\n            this.processStoredIceCandidates('guest');\n          }, 1000);\n          \n          console.log('Remote description set successfully');\n          return;\n        } catch (error) {\n          console.error('Failed to set remote description:', error);\n        }\n      }\n      \n      if (attempts < maxAttempts) {\n        setTimeout(checkForAnswer, 1000);\n      } else {\n        console.error('Timeout waiting for answer');\n      }\n    };\n    checkForAnswer();\n  }\n\n  storeIceCandidate(candidate, role) {\n    const key = `ice_${this.roomId}_${role}`;\n    const existing = JSON.parse(localStorage.getItem(key) || '[]');\n    existing.push({\n      candidate: candidate,\n      timestamp: Date.now()\n    });\n    localStorage.setItem(key, JSON.stringify(existing));\n    console.log(`Stored ICE candidate for ${role}:`, candidate.candidate);\n  }\n\n  async processStoredIceCandidates(role) {\n    const key = `ice_${this.roomId}_${role}`;\n    const candidates = JSON.parse(localStorage.getItem(key) || '[]');\n    \n    console.log(`Processing ${candidates.length} ICE candidates for ${role}`);\n    \n    for (const candidateData of candidates) {\n      try {\n        await this.localConnection.addIceCandidate(candidateData.candidate);\n        console.log(`✅ Added ICE candidate for ${role}`);\n      } catch (error) {\n        console.error(`Failed to add ICE candidate for ${role}:`, error);\n      }\n    }\n    \n    // Continue polling for new candidates, but less frequently\n    setTimeout(() => {\n      const newCandidates = JSON.parse(localStorage.getItem(key) || '[]');\n      if (newCandidates.length > candidates.length) {\n        this.processStoredIceCandidates(role);\n      } else {\n        // Check again in 5 seconds if no new candidates\n        setTimeout(() => this.processStoredIceCandidates(role), 5000);\n      }\n    }, 2000);\n  }\n\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      try {\n        this.dataChannel.send(JSON.stringify(data));\n      } catch (error) {\n        console.error('Failed to send data:', error);\n      }\n    } else {\n      console.warn('Data channel not ready, state:', this.dataChannel?.readyState || 'null');\n    }\n  }\n\n  disconnect() {\n    console.log('Disconnecting WebRTC...');\n    \n    if (this.dataChannel) {\n      this.dataChannel.close();\n    }\n    if (this.localConnection) {\n      this.localConnection.close();\n    }\n    \n    // Clean up localStorage\n    if (this.roomId) {\n      localStorage.removeItem(`offer_${this.roomId}`);\n      localStorage.removeItem(`answer_${this.roomId}`);\n      localStorage.removeItem(`ice_${this.roomId}_host`);\n      localStorage.removeItem(`ice_${this.roomId}_guest`);\n      console.log('Cleaned up localStorage for room:', this.roomId);\n    }\n  }\n}\n\nexport default WebRTCManager; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}