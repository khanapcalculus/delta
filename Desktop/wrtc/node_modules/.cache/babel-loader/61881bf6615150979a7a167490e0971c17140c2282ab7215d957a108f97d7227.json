{"ast":null,"code":"import { io } from 'socket.io-client';\nclass WebRTCManager {\n  constructor() {\n    this.peerConnection = null;\n    this.dataChannel = null;\n    this.socket = null;\n    this.roomId = null;\n    this.isHost = false;\n    this.onConnectionStateChange = null;\n    this.onDataReceived = null;\n    this.onDebugLog = null;\n    this.connectionTimeout = null;\n\n    // WebRTC configuration with STUN servers\n    this.config = {\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }, {\n        urls: 'stun:stun2.l.google.com:19302'\n      }],\n      iceCandidatePoolSize: 10\n    };\n  }\n\n  // Connect to signaling server\n  connectToSignalingServer() {\n    this.debugLog('üîó Connecting to signaling server...');\n\n    // Use the same host as the current page, but port 3001 for signaling\n    const currentHost = window.location.hostname;\n    const protocol = window.location.protocol === 'https:' ? 'https' : 'http';\n    const signalingUrl = `${protocol}://${currentHost}:3001`;\n    this.debugLog(`üì° Signaling server URL: ${signalingUrl}`);\n    this.debugLog(`üåç Current page: ${window.location.href}`);\n    this.socket = io(signalingUrl, {\n      transports: ['websocket', 'polling'],\n      timeout: 20000,\n      forceNew: true\n    });\n    this.socket.on('connect', () => {\n      this.debugLog('‚úÖ Connected to signaling server');\n    });\n    this.socket.on('disconnect', reason => {\n      this.debugLog(`‚ùå Disconnected from signaling server: ${reason}`);\n    });\n    this.socket.on('connect_error', error => {\n      this.debugLog(`‚ùå Connection error: ${error.message}`);\n      this.debugLog(`üîß Trying to connect to: ${signalingUrl}`);\n\n      // If HTTPS fails, suggest HTTP fallback\n      if (protocol === 'https' && error.message.includes('certificate')) {\n        this.debugLog('üí° Try accessing both the app and signaling server via HTTP instead');\n      }\n    });\n\n    // Listen for WebRTC signaling events\n    this.setupSignalingListeners();\n  }\n  setupSignalingListeners() {\n    // Handle incoming offer\n    this.socket.on('webrtc-offer', async data => {\n      this.debugLog('üì• Received WebRTC offer');\n      try {\n        await this.handleOffer(data.offer);\n        this.debugLog('‚úÖ Processed offer and sent answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      }\n    });\n\n    // Handle incoming answer\n    this.socket.on('webrtc-answer', async data => {\n      this.debugLog('üì• Received WebRTC answer');\n      try {\n        await this.handleAnswer(data.answer);\n        this.debugLog('‚úÖ Processed answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      }\n    });\n\n    // Handle ICE candidates\n    this.socket.on('webrtc-ice-candidate', async data => {\n      this.debugLog('üßä Received ICE candidate');\n      try {\n        await this.handleIceCandidate(data.candidate);\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling ICE candidate: ${error.message}`);\n      }\n    });\n\n    // Handle call initiation (for host)\n    this.socket.on('start-call', async () => {\n      this.debugLog('üöÄ Starting call as host');\n      await this.createOffer();\n    });\n\n    // Handle user events\n    this.socket.on('user-joined', data => {\n      this.debugLog(`üëã User joined room (${data.participantCount} total)`);\n    });\n    this.socket.on('user-left', data => {\n      this.debugLog(`üëã User left room (${data.participantCount} remaining)`);\n      if (data.participantCount === 0) {\n        this.cleanup();\n      }\n    });\n  }\n\n  // Join or create a room\n  async joinRoom(roomId) {\n    if (!this.socket) {\n      this.connectToSignalingServer();\n      await new Promise(resolve => {\n        this.socket.on('connect', resolve);\n      });\n    }\n    return new Promise((resolve, reject) => {\n      this.roomId = roomId;\n      this.socket.emit('join-room', roomId, response => {\n        if (response.success) {\n          this.isHost = response.isHost;\n          this.debugLog(`‚úÖ Joined room as ${this.isHost ? 'HOST' : 'GUEST'}`);\n          this.debugLog(`üë• Participants: ${response.participantCount}/2`);\n\n          // Initialize WebRTC\n          this.initializePeerConnection();\n          resolve({\n            success: true,\n            isHost: this.isHost,\n            participantCount: response.participantCount\n          });\n        } else {\n          this.debugLog(`‚ùå Failed to join room: ${response.message}`);\n          reject(new Error(response.message));\n        }\n      });\n    });\n  }\n  initializePeerConnection() {\n    this.debugLog('üîÑ Initializing peer connection...');\n    this.peerConnection = new RTCPeerConnection(this.config);\n\n    // Create data channel (host only)\n    if (this.isHost) {\n      this.dataChannel = this.peerConnection.createDataChannel('whiteboard', {\n        ordered: true\n      });\n      this.setupDataChannel();\n      this.debugLog('üì∫ Data channel created (host)');\n    }\n\n    // Handle incoming data channel (guest)\n    this.peerConnection.ondatachannel = event => {\n      this.debugLog('üì∫ Data channel received (guest)');\n      this.dataChannel = event.channel;\n      this.setupDataChannel();\n    };\n\n    // Handle ICE candidates\n    this.peerConnection.onicecandidate = event => {\n      if (event.candidate) {\n        this.debugLog('üßä Sending ICE candidate');\n        this.socket.emit('webrtc-ice-candidate', {\n          candidate: event.candidate\n        });\n      }\n    };\n\n    // Monitor connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      const state = this.peerConnection.connectionState;\n      this.debugLog(`üîÑ Connection state: ${state}`);\n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(state);\n      }\n      if (state === 'connected') {\n        this.debugLog('üéâ WebRTC connection established!');\n        if (this.connectionTimeout) {\n          clearTimeout(this.connectionTimeout);\n        }\n      } else if (state === 'failed' || state === 'disconnected') {\n        this.debugLog('‚ùå Connection failed or disconnected');\n        this.cleanup();\n      }\n    };\n\n    // Set connection timeout\n    this.connectionTimeout = setTimeout(() => {\n      var _this$peerConnection;\n      if (((_this$peerConnection = this.peerConnection) === null || _this$peerConnection === void 0 ? void 0 : _this$peerConnection.connectionState) !== 'connected') {\n        this.debugLog('‚è∞ Connection timeout - cleaning up');\n        this.cleanup();\n      }\n    }, 30000); // 30 second timeout\n  }\n  setupDataChannel() {\n    this.dataChannel.onopen = () => {\n      this.debugLog('üì∫ Data channel opened');\n    };\n    this.dataChannel.onclose = () => {\n      this.debugLog('üì∫ Data channel closed');\n    };\n    this.dataChannel.onmessage = event => {\n      if (this.onDataReceived) {\n        const data = JSON.parse(event.data);\n        this.onDataReceived(data);\n      }\n    };\n    this.dataChannel.onerror = error => {\n      this.debugLog(`‚ùå Data channel error: ${error}`);\n    };\n  }\n  async createOffer() {\n    try {\n      this.debugLog('üì§ Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n      await this.peerConnection.setLocalDescription(offer);\n      this.socket.emit('webrtc-offer', {\n        offer\n      });\n      this.debugLog('üì§ Offer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error creating offer: ${error.message}`);\n      throw error;\n    }\n  }\n  async handleOffer(offer) {\n    try {\n      await this.peerConnection.setRemoteDescription(offer);\n      const answer = await this.peerConnection.createAnswer();\n      await this.peerConnection.setLocalDescription(answer);\n      this.socket.emit('webrtc-answer', {\n        answer\n      });\n      this.debugLog('üì§ Answer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      throw error;\n    }\n  }\n  async handleAnswer(answer) {\n    try {\n      await this.peerConnection.setRemoteDescription(answer);\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      throw error;\n    }\n  }\n  async handleIceCandidate(candidate) {\n    try {\n      await this.peerConnection.addIceCandidate(candidate);\n    } catch (error) {\n      this.debugLog(`‚ùå Error adding ICE candidate: ${error.message}`);\n    }\n  }\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      this.dataChannel.send(JSON.stringify(data));\n      return true;\n    }\n    return false;\n  }\n  getConnectionState() {\n    var _this$peerConnection2;\n    return ((_this$peerConnection2 = this.peerConnection) === null || _this$peerConnection2 === void 0 ? void 0 : _this$peerConnection2.connectionState) || 'new';\n  }\n  cleanup() {\n    this.debugLog('üßπ Cleaning up WebRTC connection...');\n    if (this.connectionTimeout) {\n      clearTimeout(this.connectionTimeout);\n    }\n    if (this.dataChannel) {\n      this.dataChannel.close();\n      this.dataChannel = null;\n    }\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    this.roomId = null;\n    this.isHost = false;\n  }\n  debugLog(message) {\n    console.log(`[WebRTC] ${message}`);\n    if (this.onDebugLog) {\n      this.onDebugLog(message);\n    }\n  }\n}\nexport default WebRTCManager;","map":{"version":3,"names":["io","WebRTCManager","constructor","peerConnection","dataChannel","socket","roomId","isHost","onConnectionStateChange","onDataReceived","onDebugLog","connectionTimeout","config","iceServers","urls","iceCandidatePoolSize","connectToSignalingServer","debugLog","currentHost","window","location","hostname","protocol","signalingUrl","href","transports","timeout","forceNew","on","reason","error","message","includes","setupSignalingListeners","data","handleOffer","offer","handleAnswer","answer","handleIceCandidate","candidate","createOffer","participantCount","cleanup","joinRoom","Promise","resolve","reject","emit","response","success","initializePeerConnection","Error","RTCPeerConnection","createDataChannel","ordered","setupDataChannel","ondatachannel","event","channel","onicecandidate","onconnectionstatechange","state","connectionState","clearTimeout","setTimeout","_this$peerConnection","onopen","onclose","onmessage","JSON","parse","onerror","setLocalDescription","setRemoteDescription","createAnswer","addIceCandidate","sendData","readyState","send","stringify","getConnectionState","_this$peerConnection2","close","disconnect","console","log"],"sources":["C:/Users/eniac/Desktop/wrtc/src/services/WebRTCManager.js"],"sourcesContent":["import { io } from 'socket.io-client';\n\nclass WebRTCManager {\n  constructor() {\n    this.peerConnection = null;\n    this.dataChannel = null;\n    this.socket = null;\n    this.roomId = null;\n    this.isHost = false;\n    this.onConnectionStateChange = null;\n    this.onDataReceived = null;\n    this.onDebugLog = null;\n    this.connectionTimeout = null;\n    \n    // WebRTC configuration with STUN servers\n    this.config = {\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n        { urls: 'stun:stun2.l.google.com:19302' }\n      ],\n      iceCandidatePoolSize: 10\n    };\n  }\n\n  // Connect to signaling server\n  connectToSignalingServer() {\n    this.debugLog('üîó Connecting to signaling server...');\n    \n    // Use the same host as the current page, but port 3001 for signaling\n    const currentHost = window.location.hostname;\n    const protocol = window.location.protocol === 'https:' ? 'https' : 'http';\n    const signalingUrl = `${protocol}://${currentHost}:3001`;\n    \n    this.debugLog(`üì° Signaling server URL: ${signalingUrl}`);\n    this.debugLog(`üåç Current page: ${window.location.href}`);\n    \n    this.socket = io(signalingUrl, {\n      transports: ['websocket', 'polling'],\n      timeout: 20000,\n      forceNew: true\n    });\n\n    this.socket.on('connect', () => {\n      this.debugLog('‚úÖ Connected to signaling server');\n    });\n\n    this.socket.on('disconnect', (reason) => {\n      this.debugLog(`‚ùå Disconnected from signaling server: ${reason}`);\n    });\n\n    this.socket.on('connect_error', (error) => {\n      this.debugLog(`‚ùå Connection error: ${error.message}`);\n      this.debugLog(`üîß Trying to connect to: ${signalingUrl}`);\n      \n      // If HTTPS fails, suggest HTTP fallback\n      if (protocol === 'https' && error.message.includes('certificate')) {\n        this.debugLog('üí° Try accessing both the app and signaling server via HTTP instead');\n      }\n    });\n\n    // Listen for WebRTC signaling events\n    this.setupSignalingListeners();\n  }\n\n  setupSignalingListeners() {\n    // Handle incoming offer\n    this.socket.on('webrtc-offer', async (data) => {\n      this.debugLog('üì• Received WebRTC offer');\n      try {\n        await this.handleOffer(data.offer);\n        this.debugLog('‚úÖ Processed offer and sent answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      }\n    });\n\n    // Handle incoming answer\n    this.socket.on('webrtc-answer', async (data) => {\n      this.debugLog('üì• Received WebRTC answer');\n      try {\n        await this.handleAnswer(data.answer);\n        this.debugLog('‚úÖ Processed answer');\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      }\n    });\n\n    // Handle ICE candidates\n    this.socket.on('webrtc-ice-candidate', async (data) => {\n      this.debugLog('üßä Received ICE candidate');\n      try {\n        await this.handleIceCandidate(data.candidate);\n      } catch (error) {\n        this.debugLog(`‚ùå Error handling ICE candidate: ${error.message}`);\n      }\n    });\n\n    // Handle call initiation (for host)\n    this.socket.on('start-call', async () => {\n      this.debugLog('üöÄ Starting call as host');\n      await this.createOffer();\n    });\n\n    // Handle user events\n    this.socket.on('user-joined', (data) => {\n      this.debugLog(`üëã User joined room (${data.participantCount} total)`);\n    });\n\n    this.socket.on('user-left', (data) => {\n      this.debugLog(`üëã User left room (${data.participantCount} remaining)`);\n      if (data.participantCount === 0) {\n        this.cleanup();\n      }\n    });\n  }\n\n  // Join or create a room\n  async joinRoom(roomId) {\n    if (!this.socket) {\n      this.connectToSignalingServer();\n      await new Promise(resolve => {\n        this.socket.on('connect', resolve);\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      this.roomId = roomId;\n      \n      this.socket.emit('join-room', roomId, (response) => {\n        if (response.success) {\n          this.isHost = response.isHost;\n          this.debugLog(`‚úÖ Joined room as ${this.isHost ? 'HOST' : 'GUEST'}`);\n          this.debugLog(`üë• Participants: ${response.participantCount}/2`);\n          \n          // Initialize WebRTC\n          this.initializePeerConnection();\n          \n          resolve({\n            success: true,\n            isHost: this.isHost,\n            participantCount: response.participantCount\n          });\n        } else {\n          this.debugLog(`‚ùå Failed to join room: ${response.message}`);\n          reject(new Error(response.message));\n        }\n      });\n    });\n  }\n\n  initializePeerConnection() {\n    this.debugLog('üîÑ Initializing peer connection...');\n    \n    this.peerConnection = new RTCPeerConnection(this.config);\n\n    // Create data channel (host only)\n    if (this.isHost) {\n      this.dataChannel = this.peerConnection.createDataChannel('whiteboard', {\n        ordered: true\n      });\n      this.setupDataChannel();\n      this.debugLog('üì∫ Data channel created (host)');\n    }\n\n    // Handle incoming data channel (guest)\n    this.peerConnection.ondatachannel = (event) => {\n      this.debugLog('üì∫ Data channel received (guest)');\n      this.dataChannel = event.channel;\n      this.setupDataChannel();\n    };\n\n    // Handle ICE candidates\n    this.peerConnection.onicecandidate = (event) => {\n      if (event.candidate) {\n        this.debugLog('üßä Sending ICE candidate');\n        this.socket.emit('webrtc-ice-candidate', {\n          candidate: event.candidate\n        });\n      }\n    };\n\n    // Monitor connection state\n    this.peerConnection.onconnectionstatechange = () => {\n      const state = this.peerConnection.connectionState;\n      this.debugLog(`üîÑ Connection state: ${state}`);\n      \n      if (this.onConnectionStateChange) {\n        this.onConnectionStateChange(state);\n      }\n\n      if (state === 'connected') {\n        this.debugLog('üéâ WebRTC connection established!');\n        if (this.connectionTimeout) {\n          clearTimeout(this.connectionTimeout);\n        }\n      } else if (state === 'failed' || state === 'disconnected') {\n        this.debugLog('‚ùå Connection failed or disconnected');\n        this.cleanup();\n      }\n    };\n\n    // Set connection timeout\n    this.connectionTimeout = setTimeout(() => {\n      if (this.peerConnection?.connectionState !== 'connected') {\n        this.debugLog('‚è∞ Connection timeout - cleaning up');\n        this.cleanup();\n      }\n    }, 30000); // 30 second timeout\n  }\n\n  setupDataChannel() {\n    this.dataChannel.onopen = () => {\n      this.debugLog('üì∫ Data channel opened');\n    };\n\n    this.dataChannel.onclose = () => {\n      this.debugLog('üì∫ Data channel closed');\n    };\n\n    this.dataChannel.onmessage = (event) => {\n      if (this.onDataReceived) {\n        const data = JSON.parse(event.data);\n        this.onDataReceived(data);\n      }\n    };\n\n    this.dataChannel.onerror = (error) => {\n      this.debugLog(`‚ùå Data channel error: ${error}`);\n    };\n  }\n\n  async createOffer() {\n    try {\n      this.debugLog('üì§ Creating offer...');\n      const offer = await this.peerConnection.createOffer();\n      await this.peerConnection.setLocalDescription(offer);\n      \n      this.socket.emit('webrtc-offer', { offer });\n      this.debugLog('üì§ Offer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error creating offer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async handleOffer(offer) {\n    try {\n      await this.peerConnection.setRemoteDescription(offer);\n      const answer = await this.peerConnection.createAnswer();\n      await this.peerConnection.setLocalDescription(answer);\n      \n      this.socket.emit('webrtc-answer', { answer });\n      this.debugLog('üì§ Answer sent');\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling offer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async handleAnswer(answer) {\n    try {\n      await this.peerConnection.setRemoteDescription(answer);\n    } catch (error) {\n      this.debugLog(`‚ùå Error handling answer: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async handleIceCandidate(candidate) {\n    try {\n      await this.peerConnection.addIceCandidate(candidate);\n    } catch (error) {\n      this.debugLog(`‚ùå Error adding ICE candidate: ${error.message}`);\n    }\n  }\n\n  sendData(data) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      this.dataChannel.send(JSON.stringify(data));\n      return true;\n    }\n    return false;\n  }\n\n  getConnectionState() {\n    return this.peerConnection?.connectionState || 'new';\n  }\n\n  cleanup() {\n    this.debugLog('üßπ Cleaning up WebRTC connection...');\n    \n    if (this.connectionTimeout) {\n      clearTimeout(this.connectionTimeout);\n    }\n\n    if (this.dataChannel) {\n      this.dataChannel.close();\n      this.dataChannel = null;\n    }\n\n    if (this.peerConnection) {\n      this.peerConnection.close();\n      this.peerConnection = null;\n    }\n\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n\n    this.roomId = null;\n    this.isHost = false;\n  }\n\n  debugLog(message) {\n    console.log(`[WebRTC] ${message}`);\n    if (this.onDebugLog) {\n      this.onDebugLog(message);\n    }\n  }\n}\n\nexport default WebRTCManager; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}